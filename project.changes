----QUIT----2020-01-22T20:54:30.239682+01:00 Pharo8.0-SNAPSHOT-32bit-0932da8.image priorSource: 0!----QUIT----2020-01-22T20:54:52.539489+01:00 Pharo8.0-SNAPSHOT-32bit-0932da8.image priorSource: 0!!RawObjTest commentStamp: 'StephaneDucasse 11/17/2014 11:09' prior: 0!These tests are based on a setup that does not rely on structure for the accessors.!!ObjClassInspector commentStamp: 'StephaneDucasse 11/16/2014 23:11' prior: 0!I'm a simple inspector that can inspect fixed structured Obj class."creating class by hand"| coloredPointClass |coloredPointClass := Obj new: 6.coloredPointClass at: coloredPointClass offsetForName put: #ObjColoredPoint.coloredPointClass at: coloredPointClass offsetForClass put: #ObjClass.coloredPointClass at: coloredPointClass offsetForIVs put: #( #class #x #y #color).coloredPointClass at: coloredPointClass offsetForSuperclass put: #ObjPoint.coloredPointClass at: coloredPointClass offsetForMethodDict	put: (IdentityDictionary new).coloredPointClass.ObjClassInspector basicInspect: coloredPointClass.!!ObjExampleTest class methodsFor: 'first user-defined metaclasses'!setMetaclassDefinition	"self setMetaclassDefinition"	| setClass |	setClass := Obj ObjClass				send: #new				withArguments: #(#(#name: #ObjSet #iv: #(#myInstances) #superclass: #ObjClass)).	"initialize on a metaclass"	setClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'			objself binarySuper: #initialize with: initArray from: superClassOfClassDefiningTheMethod.			objself send: #setIV				withArguments: (Array with: #myInstances with: OrderedCollection new).			objself'.	setClass addUnaryMethod: #instances		withBody: 'objself binarySend: #getIV with: #myInstances'.	setClass addMethod: #new		args: 'initArray'		withBody: 			'| newInst others |			newInst := objself super: #new withArguments: (Array with: initArray) from: superClassOfClassDefiningTheMethod.			others := objself unarySend: #instances.			others := others add: newInst;						yourself.			objself send: #setIV withArguments: (Array with: #myInstances with: others).			newInst'! !!ObjExampleTest class methodsFor: 'first user-defined metaclasses' stamp: 'StephaneDucasse 11/26/2014 22:04'!setMetaclassExample	"self setMetaclassExample"	| memoPointClass |	self setMetaclassDefinition.	memoPointClass := Obj ObjSet 						send: #new						withArguments: #(#(#name: #ObjMemoPoint  #iv: #() #superclass: #ObjPoint)).	memoPointClass send: #new withArguments: #(#(#x: 24 #y: 6)).	memoPointClass send: #new withArguments: #(#(#x: 15 #y: 10)).	^memoPointClass send: #instances withArguments: #().! !!ObjExampleTest methodsFor: 'setup'!abstractMetaclassDefinition 	(Obj giveClassNamed: #ObjClass)					 		send: #new							withArguments: #(#(#name: #ObjAbstractClass #iv: #() #superclass: #ObjClass)).	Obj ObjAbstractClass 		addMethod: #new		args: 'initArray'		withBody: 			' objself error: '' the class '' , objself objName asString , '' is abstract'''! !!ObjExampleTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:52'!defineObjAbstractPoint	(Obj ObjAbstractClass)		send: #new		withArguments: #(#(#name: #ObjAbstractPoint #iv: #() #superclass: #ObjObject)).	Obj ObjAbstractPoint		addUnaryMethod: #givex		withBody: 'objself  valueOfInstanceVariable: #x '.	Obj ObjAbstractPoint 		addUnaryMethod: #display		withBody: 			'Transcript cr;				show: ''aPoint with x = ''.			Transcript show: (objself send: #givex withArguments: #()) printString;				cr'.! !!ObjExampleTest methodsFor: 'setup'!defineObjPoint	Obj ObjClass send: #new		withArguments: #(#(#name: #ObjPoint #iv: #(#x #y) #superclass: #ObjAbstractPoint)).! !!ObjExampleTest methodsFor: 'setup'!setUp	Obj bootstrap.	self abstractMetaclassDefinition.	self defineObjAbstractPoint.	self defineObjPoint! !!ObjExampleTest methodsFor: 'test abstract'!testAbstractMetaclassExample	self should: [Obj ObjAbstractClass send: #new withArguments: #(#(#x: 24 #y: 6))] raise: Error.! !!ObjExampleTest methodsFor: 'test abstract'!testAbstractMetaclassExampleWithConcreteSubclass	self shouldnt: [Obj ObjPoint send: #new withArguments: #(#(#x: 24 #y: 6))]		raise: Error! !!ObjExampleTest methodsFor: 'test abstract' stamp: 'StephaneDucasse 11/27/2014 20:48'!testColoredPoint	| coloredPointClass aColoredPoint |	coloredPointClass := (Obj ObjClass)						 	send: #new 							withArguments: #((#name: #ObjColoredPoint 							           		   #iv: #(#color) 							            	  #superclass: #ObjPoint)).	aColoredPoint := coloredPointClass send: #new withArguments: #((#x: 24 #y: 6 #color: #blue)).		"first messages sent"	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 24.	aColoredPoint send: #setIV withArguments: #(#x 25).	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 25.	self assert: (aColoredPoint send: #getIV withArguments: #(#color)) = #blue.		"adding some methods"	coloredPointClass 		addUnaryMethod: #giveColor		withBody: 'objself send: #getIV withArguments: #(#color)'.	coloredPointClass 		addMethod: #setColor		args: 'col'		withBody:' objself send: #setIV withArguments: (Array with: #color with: col)'.	coloredPointClass addUnaryMethod: #display		withBody:  			'objself super: #display withArguments: #() from: superClassOfClassDefiningTheMethod.			Transcript cr;				show: '' with Color = ''.			Transcript show: (objself send: #giveColor withArguments: #()) printString;				cr'.	self assert: (aColoredPoint send: #giveColor withArguments: #()) = #blue.		self assert: (aColoredPoint send: #givex withArguments: #()) = 25.		aColoredPoint send: #display withArguments: #().! !!ObjMessageTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/26/2014 15:33'!setUp	Obj bootstrap.	Obj objClassStructureMessage.! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:05'!testMessageClassMethods	"self debug: #testMessageClassMethods"		| msg |	Obj addMessagesForErrorHandling.	msg := Obj ObjMessage 				send: #new 				withArguments: #(#(#receiver: 24 #selector: #factorial)).		self assert: (msg send: #receiver2 withArguments: #()) equals: 24.	self assert: (msg send: #receiver withArguments: #()) equals: 24.	self assert: (msg send: #selector withArguments: #()) equals: #factorial.		msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #+ arguments: #(25))).	self assert: (msg send: #arguments withArguments: #())  equals: #(25).! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 14:52'!testMessageClassMethodsDefined	"self debug: #testMessageClassMethodsDefined"		| msg |	Obj addMessagesForErrorHandling.	self deny: Obj ObjMessage objMethodDict size isZero! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 10:16'!testMessageClassStructureDeclared	Obj objClassStructureMessage.	self assert: Obj ObjMessage objName = #ObjMessage.	self assert: Obj ObjMessage objClass objName= #ObjClass.	self assert: Obj ObjMessage objIVs asArray = #(#class #receiver #selector #arguments).	self assert: Obj ObjMessage objSuperclass = Obj ObjObject	! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 15:05'!testUsingPrimitivesMessageClassMethods	| msg |	msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #factorial)).		self assert: (msg at: 1) equals: #ObjMessage.	self assert: (msg at: 2) equals: 24.	self assert: (msg at: 3) equals: #factorial.		msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #+ arguments: #(25))).	self assert: (msg at: 4)  equals: #(25).! !!ObjTest methodsFor: 'setup'!assembleClassClass	classClass := Obj new: 6.	classClass at: classClass offsetForName put: #ObjClass.	classClass at: classClass offsetForClass put: #ObjClass.	classClass at: classClass offsetForIVs		put: #(#class #name #superclass #iv #keywords #methodDict).	classClass at: classClass offsetForKeywords		put: #(#name: #superclass: #iv: #keywords: #methodDict:).	classClass at: classClass offsetForSuperclass put: #ObjObject.	classClass at: classClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: classClass! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 10/22/2009 16:24'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint at: 1 put: #ObjColoredPoint.	aColoredPoint at: 2 put: 10.	aColoredPoint at: 3 put: 15.	aColoredPoint at: 4 put: #blue! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:36'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass at: pointClass offsetForName put: #ObjColoredPoint.	coloredPointClass at: pointClass offsetForClass put: #ObjClass.		"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."	coloredPointClass at: pointClass offsetForIVs put: #( #class #x #y #color).	coloredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.	coloredPointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 2/15/2011 16:10'!assembleIncrementalColoredInstance		aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.	aIncrementalColoredPoint at: 2 put: 10.	aIncrementalColoredPoint at: 3 put: 15.	aIncrementalColoredPoint at: 4 put: #blue! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:37'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass at: pointClass offsetForName put: #ObjIncrementalColoredPoint.	incrementalColoredPointClass at: pointClass offsetForClass put: #ObjClass.		"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."	incrementalColoredPointClass at: pointClass offsetForIVs put: #( #color).	incrementalColoredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.	incrementalColoredPointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/26/2014 16:01'!assembleObjectClass	objectClass := Obj new: 6.	objectClass at: objectClass offsetForName put: #ObjObject.	objectClass at: objectClass offsetForClass put: #ObjClass.	objectClass at: objectClass offsetForIVs put: #(#class).	objectClass at: objectClass offsetForKeywords put: #().	objectClass at: objectClass offsetForSuperclass put: nil.	objectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).	Obj declareClass: objectClass.	"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent	the superclass of ObjObject"	(objectClass at: objectClass offsetForMethodDict) at: #print		put: 			([:superClassOfClassDefiningTheMethod |				[:objself | 			Transcript show: 'I''am an Object';				cr]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #error		put: 			([:superClassOfClassDefiningTheMethod |				[:object :arrayOfArguments | 			Transcript show: 'Error: selector ' , arrayOfArguments first printString , ' not understood';				cr.				Error signal]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #getIV		put: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #setIV		put: 			([:superClassOfClassDefiningTheMethod | [:object :iv :val | 			object at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #bar		put: 			([:superClassOfClassDefiningTheMethod | [:objself | 					5]] value: nil).! !!ObjTest methodsFor: 'setup'!assemblePointClass	| cl |	cl := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (cl at: cl offsetForIVs) size.	pointClass at: pointClass offsetForName put: #ObjPoint.	pointClass at: pointClass offsetForClass put: #ObjClass.	pointClass at: pointClass offsetForIVs put: #(#class #x #y).	pointClass at: pointClass offsetForKeywords put: #(#x: #y:).	pointClass at: pointClass offsetForSuperclass put: #ObjObject.	pointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict) at: #x		put: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | [:objself | 			Transcript show: 'I''am a Point';				cr]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'ObjPoint>>foo';cr.				5				]] value: objectClass)! !!ObjTest methodsFor: 'setup'!assemblePointInstance	aPoint := Obj new: 3.	aPoint at: 1 put: #ObjPoint.	aPoint at: 2 put: 10.	aPoint at: 3 put: 15! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 2/15/2011 16:15'!setUp	"self new setUp"	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !!ObjTest methodsFor: 'step5-tests-allocate' stamp: 'StephaneDucasse 11/21/2015 15:44'!testAllocate  "(self  selector: #testAllocate) run"  | newInstance |  newInstance := pointClass allocateAnInstance.  self assert: (newInstance at: 1) = #ObjPoint.  self assert: (newInstance size) = 3.  self assert: (newInstance at: 2) isNil.  self assert: (newInstance at: 3) isNil.  self assert: (newInstance objClass = pointClass)! !!ObjTest methodsFor: 'utilities tests'!testBlockArgsFrom	self assert: (Obj new blockArgsFrom: ' abc def ghi ')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: 'abc def ghi')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: '')  = ''.! !!ObjTest methodsFor: 'utilities tests' stamp: 'NicoPAez 10/21/2010 10:22'!testBlockBodyFromHeaderAndBody	"a method with one argument: val"	self assert: (Obj new stringOfBlockBodyFromHeader: 'val' andBody: 'objself send: #setIV 										 withArguments: (Array with: #x with: val).')										= '[ :superClassOfClassDefiningTheMethod |		[ :objself :val |					 objself send: #setIV 										 withArguments: (Array with: #x with: val).] ]'.	"a method without arg"	self assert: (Obj new stringOfBlockBodyFromHeader: '' andBody: 'objself unarySend: #getx.') 	='[ :superClassOfClassDefiningTheMethod |		[ :objself  |					 objself unarySend: #getx.] ]'	! !!ObjTest methodsFor: 'step3-tests-class access'!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (aPoint objClass = pointClass)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:52'!testErrorRaisedSendWhenErrorInLookup	"(self  selector: #testErrorRaisedSendWhenErrorInLookup) run"		self should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/27/2014 21:15'!testErrorRedefinition	"(self  run: #testErrorRedefinition)"		self should: [aPoint send: #zork withArguments: #()] raise: Error.	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).		self assert: (aPoint send: #zork withArguments: #()) = 33.	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).	self assert: (aPoint send: #zork withArguments: #(44)) = 33.! !!ObjTest methodsFor: 'step4-tests-iv management'!testIVOffset	"(self  selector: #testIVOffset) run"	self assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).	self assert: ((pointClass offsetFromClassOfInstanceVariable: #lulu ) = 0)! !!ObjTest methodsFor: 'step4-tests-iv management'!testIVOffsetAndValue	"(self  selector: #testIVOffsetAndValue) run"	self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).	self assert: ((aPoint valueOfInstanceVariable: #x ) = 10)! !!ObjTest methodsFor: 'step7-tests-initialize' stamp: 'StephaneDucasse 11/21/2015 16:16'!testInitialize	"(self  selector: #testInitialize) run"	| newInstance  |	newInstance := pointClass allocateAnInstance.	newInstance initializeUsing: #(#y: 2 #z: 3 #t: 55 #x: 1).	self assert: (newInstance at: 1) equals: #ObjPoint.	self assert: (newInstance at: 2) equals: 1.	self assert: (newInstance at: 3) equals: 2.! !!ObjTest methodsFor: 'step8-tests-instance variable inheritance'!testInstanceVariableInheritance	"(self  selector: #testInstanceVariableInheritance) run"	"a better choice would be to throw an exception if there are duplicates"	self assert: 			((Obj new computeNewIVFrom: #(#a #b #c #d) asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #b #c #d #z #t) asOrderedCollection).	self assert: 			((Obj new computeNewIVFrom: #() asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #z #b #t) asOrderedCollection)! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'StephaneDucasse 2/15/2011 16:12'!testInstanceVariableInheritanceFromAClass	"(self  selector: #testInstanceVariableInheritanceFromAClass) run"		aIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).		self assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).	self assert: ((incrementalColoredPointClass offsetFromClassOfInstanceVariable: #x ) = 2).	! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'StephaneDucasse 2/15/2011 16:14'!testInstanceVariableInheritanceFromAObject	"(self  selector: #testInstanceVariableInheritanceFromAObject) run"		aIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).		self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).	self assert: ((aIncrementalColoredPoint offsetFromObjectOfInstanceVariable: #x ) = 2).			! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'JB 10/9/2009 16:52'!testInstanceVariableInheritanceNotFind	"(self  selector: #testInstanceVariableInheritanceNotFind) run"		self should: [aPoint offsetFromObjectOfInstanceVariable: #zork ] raise: Error.			! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'JB 10/13/2009 16:23'!testInstanceVariableInheritanceNumberOfInstanceVar	"(self  selector: #testInstanceVariableInheritanceNumberOfInstanceVar) run"		self assert: ((pointClass numberOfIVs ) = 3).	self assert: ((coloredPointClass numberOfIVs ) = 4).	! !!ObjTest methodsFor: 'step6-tests-keywords'!testKeywords	"(self  selector: #testKeywords) run"	| dummyObject |	dummyObject := Obj new.	self assert: 			((dummyObject generateKeywords: #(#titi #toto #lulu))				= #(#titi: #toto: #lulu:)).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 33 #x 23)				ifAbsent: 2) = 23).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 23)				ifAbsent: 2) = 2).	self assert: 			((dummyObject returnValuesFrom: #(#x 22 #y 35) followingSchema: #(#y #yy #x #y))				= #(35 nil 22 35))! !!ObjTest methodsFor: 'tests'!testMethodDefinition	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.	"define a unary method xx returning the receiver."	pointClass 		addMethod: #xx		args: ''		withBody: 'objself'.	self assert: (pointClass doesUnderstand: #xx).	self assert: (((pointClass bodyOfMethod: #xx) value: 22) = 22).	"define a unary method returning the slot x of the receiver"	pointClass 		addMethod: #getgetx		args: ''		withBody: 'objself valueOfInstanceVariable: #x'.	self assert: (pointClass doesUnderstand: #getgetx).	self assert: (((pointClass bodyOfMethod: #getgetx) value: aPoint) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookup	"(self  selector: #testMethodLookup) run"		self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookupFindSimpleMethod	"(self  selector: #testMethodLookupFindSimpleMethod) run"	self assert: ((pointClass lookup: #x)  isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookupFindSuperMethod	"(self  selector: #testMethodLookupFindSuperMethod) run"		self assert: ((coloredPointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:38'!testMethodLookupStop	"(self  selector: #testMethodLookupStop) run"		| foundMethod|	foundMethod := (pointClass lookup: #zork).	self assert: foundMethod isNil. 	"The method zork is NOT implement on pointClass, so nil is returned."	self should: [ pointClass sendError: #error withArgs: {aPoint}] raise: Error.		foundMethod := (pointClass lookup: #error).	self assert: (foundMethod isKindOf: BlockClosure).	self assert: ('*Error*' match: foundMethod printString).		"the message error defined on ObjObject requires two arguments: an object and a selector and it raises 	an error when executed. Open a Transcript to see the message trace"	self should:  [((pointClass lookup: #zork) value: 'r' value: #e)] raise: Error .! !!ObjTest methodsFor: 'tests' stamp: 'NicoPAez 10/21/2010 10:25'!testMethodManagement	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.		pointClass 		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).	self assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self assert: (pointClass doesUnderstand: #xx) not.	self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:51'!testMethodManagmentAddRemoveMethods	"(self  selector: #testMethodManagmentAddRemoveMethods) run"	pointClass 		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).	self assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self assert: (pointClass doesUnderstand: #xx) not.	self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:51'!testMethodManagmentBodyOfMethod	"(self  selector: #testMethodManagmentBodyOfMethod) run"		self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:52'!testMethodManagmentNotUnderstandBadMethod	"(self  selector: #testMethodManagmentNotUnderstandBadMethod) run"	self assert: (pointClass doesUnderstand: #xx) not.	! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:52'!testMethodManagmentUnderstandGoodMethod	"(self  selector: #testMethodManagmentUnderstandGoodMethod) run"	self assert: (pointClass doesUnderstand: #x).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:05'!testMethodNotFoundRaiseError	"(self  run: #testMethodNotFoundRaiseError)"	self should: [aPoint send: #zork withArguments: #()] raise: Error.! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/27/2014 12:18'!testMethodSelfSend	"(self  selector: #testMethodSelfSend) run"	"method found in the class PointClass"	self assert: ((aPoint send: #x withArguments: #()) = 10).	"method found in ObjClass"	self assert: ((aPoint send: #getIV withArguments: #(#x)) = 10).	"method found in ObjClass"	aPoint send: #setIV withArguments: #(y 22).	self assert: ((aPoint send: #getIV withArguments: #(#y)) = 22)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 11/26/2014 22:22'!testMethodSelfSendUnarySend	"(self  selector: #testMethodSelfSendUnarySend) run"	"method found in the class PointClass"	self assert: ((aPoint send: #x withArguments: #()) = 10).	"method found in the class PointClass"	self assert: ((aColoredPoint send: #x withArguments:#()) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:22'!testMethodSuperCall	"(self  selector: #testMethodSuperCall) run"	"foo in point return 5"	self assert: ((aPoint send: #foo withArguments: #()) = 5).	"foo in colored point is doing super foo + super foo"	self assert: ((aColoredPoint send: #foo withArguments: #()) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:23'!testMethodSuperCallOverBigHierarchy	"(self  selector: #testMethodSuperCallOverBigHierarchy) run"	"bar is defined in Object and not on Point"	self assert: (aPoint send: #bar withArguments: #()) = 5.	"bar on coloredPoint = super bar + super bar"	self assert: (aColoredPoint send: #bar withArguments: #()) = 10.! !!ObjTest methodsFor: 'utilities tests'!testMethodWithHeaderAndBody	"a method simply returning objself"	self assert: ((pointClass					methodWithHeader: ''					andBody: 'objself ') value: 2) = 2.		"a method returning its first none implicit arg"	self assert: ((pointClass 					methodWithHeader: 'val'					andBody: 'val ') value: 2 value: 33) = 33.	"a method returns its superclass of the class defining the method value"	"this anonymous method is defined in pointClass so its superclass pointer is objectClass"	self assert: ((pointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = objectClass .	self assert: ((coloredPointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = pointClass .! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:52'!testNilWhenErrorInLookup	"(self  selector: #testNilWhenErrorInLookup) run"		self assert: (pointClass lookup: #zork) isNil.	"The method zork is NOT implement on pointClass"	! !!ObjTest methodsFor: 'tests' stamp: 'SD 2/5/2013 16:47'!testPrimitiveStructure	"(self selector: #testPrimitiveStructure) run"		self assert: (pointClass objClassId = #ObjClass).	self assert: ((pointClass objName ) = #ObjPoint).	self assert: ((pointClass objSuperclassId ) = #ObjObject).	self assert: ((pointClass objIVs) = #(#class #x #y)).	self assert: ((pointClass objKeywords) = #(#x: #y:)).	self assert: ((pointClass objMethodDict) = nil) not! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjClassId	"(self selector: #testPrimitiveStructureObjClassId) run"	self assert: (pointClass objClassId = #ObjClass).! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'SD 2/5/2013 16:48'!testPrimitiveStructureObjClassIdForSimpleObject	"self run: #testPrimitiveStructureObjClassIdForSimpleObject"	self assert: (aPoint objClassId = #ObjPoint).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjIVs	"(self selector: #testPrimitiveStructureObjIVs) run"	self assert: ((pointClass objIVs) = #(#class #x #y)).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) = #(#x: #y:)).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjMethodDict	"(self selector: #testPrimitiveStructureObjMethodDict) run"	self assert: ((pointClass objMethodDict) = nil) not! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjName	"(self selector: #testPrimitiveStructureObjName) run"	self assert: ((pointClass objName ) = #ObjPoint).	! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjSuperclassId	"(self selector: #testPrimitiveStructureObjSuperclassId) run"	self assert: ((pointClass objSuperclassId ) = #ObjObject).! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 11/21/2015 18:24'!testRaisesErrorSendWhenErrorInLookup	"(self  selector: #testRaisesErrorSendWhenErrorInLookup) run"	self should: [ pointClass send: #zork withArguments: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:54'!testSendErrorRaisesErrorSendWhenErrorInLookup	"(self  selector: #testSendErrorRaisesErrorSendWhenErrorInLookup) run"		self should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: 'StephaneDucasse 11/26/2014 21:56'!testCreateObjClassMessage	"(self selector: #testCreateObjClassMessage) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self assert: ((objClass send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass)).	self assert: (objClass send: #isClass withArguments: #()).	self assert: (objClass send: #isMetaclass withArguments: #())! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: 'StephaneDucasse 11/26/2014 21:57'!testCreateObjClassStructure	"(self selector: #testCreateObjClassStructure) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self assert: (objClass objName = #ObjClass).	self assert: (objClass objClassId = #ObjClass).	self assert: (objClass objSuperclassId = #ObjObject).	self assert: (objClass objIVs asArray = #(#class #name #superclass #iv #keywords #methodDict)).	self assert: (objClass objKeywords asArray = #(#name: #superclass: #iv: #keywords: #methodDict:))! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'StephaneDucasse 11/26/2014 21:59'!testCreateObjObjectInstanceMessage	"(self selector: #testCreateObjObjectInstanceMessage) run"	| pointClass objClass pointInstance |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objClass := Obj giveClassNamed: #ObjClass.	pointClass := objClass 							send: #new							withArguments: #(#(#name: #ObjPoint #superclass: #ObjObject #iv: #(#x #y))).	pointInstance := pointClass send: #new withArguments: #(#()).	self assert: (pointInstance objClassId = #ObjPoint).	self assert: ((pointInstance send: #getIV withArguments: #(#x)) = nil).	pointInstance send: #setIV withArguments: #(#x 25).	self assert:  ((pointInstance send: #getIV withArguments: #(x)) = 25 )! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'StephaneDucasse 11/26/2014 22:00'!testCreateObjObjectMessage	"(self selector: #testCreateObjObjectMessage) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self assert: (objObject send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass).	self assert: (objObject send: #isClass withArguments: #()) not.	self assert: (objObject send: #getIV withArguments: #(#class)) = #ObjClass! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'stephane.ducasse 9/29/2008 14:32'!testCreateObjObjectStructure	"(self selector: #testCreateObjObjectStructure) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self assert: (objObject objName = #ObjObject).	self assert: (objObject objClassId = #ObjClass).	self assert: (objObject objSuperclassId isNil).	self assert: (objObject objIVs asArray = #(#class)).	self assert: (objObject objKeywords asArray = #())! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: 'StephaneDucasse 11/26/2014 22:01'!testManuallyCreateObjClassAllocate	"(self selector: #testManuallyCreateObjClassAllocate) run"	| objClass emptyClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	emptyClass := objClass send: #allocate withArguments: #().	self assert: emptyClass objClassId = #ObjClass.	self assert:  emptyClass objSuperclassId isNil.	self assert:  emptyClass objIVs isNil.	self assert:  emptyClass objKeywords isNil.	self assert:  emptyClass objMethodDict isNil.	self assert:  emptyClass objName isNil! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: 'StephaneDucasse 11/26/2014 22:01'!testManuallyCreateObjClassStructure	"(self selector: #testManuallyCreateObjClassStructure) run"	| objClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	self assert: (objClass objName = #ObjClass).	self assert: (objClass objClassId = #ObjClass).	self assert: (objClass objClass == objClass).	self assert: (objClass objSuperclassId = #ObjObject).		"the fact that the created first class inherits form ObjObject is not necessary	because there is no super calls"	self assert: (objClass objIVs = #(#class #name #superclass #iv #keywords #methodDict)).	self assert: (objClass objKeywords = #(#name: #superclass: #iv: #keywords: #methodDict:))! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:10'!assembleClassClass	classClass := Obj new: 6.	classClass at: 2 put: #ObjClass.	classClass at: 1 put: #ObjClass.	classClass at: 4 put: #(#class #name #superclass #iv #keywords #methodDict).	classClass at: 5 put: #(#name: #superclass: #iv: #keywords: #methodDict:).	classClass at: 3 put: #ObjObject.	classClass at: 6 put: (IdentityDictionary new).	Obj declareClass: classClass! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint at: 1 put: #ObjColoredPoint.	aColoredPoint at: 2 put: 10.	aColoredPoint at: 3 put: 15.	aColoredPoint at: 4 put: #blue! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:38'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass at: 2 put: #ObjColoredPoint.	coloredPointClass at: 1 put: #ObjClass.	"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."	coloredPointClass at: 4 put: #( #class #x #y #color).	coloredPointClass at: 3 put: #ObjPoint.	coloredPointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assembleIncrementalColoredInstance		aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.	aIncrementalColoredPoint at: 2 put: 10.	aIncrementalColoredPoint at: 3 put: 15.	aIncrementalColoredPoint at: 4 put: #blue! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:39'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass at: 2 put: #ObjIncrementalColoredPoint.	incrementalColoredPointClass at: 1 put: #ObjClass.	"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."	incrementalColoredPointClass at: 4 put: #( #color).	incrementalColoredPointClass at: 3 put: #ObjPoint.	incrementalColoredPointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:12'!assembleObjectClass	objectClass := Obj new: 6.	objectClass at: 2 put: #ObjObject.	objectClass at: 1 put: #ObjClass.	objectClass at: objectClass offsetForIVs put: #(#class).	objectClass at: objectClass offsetForKeywords put: #().	objectClass at: objectClass offsetForSuperclass put: nil.	objectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).	Obj declareClass: objectClass.	"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent	the superclass of ObjObject"	(objectClass at: objectClass offsetForMethodDict) at: #print		put: 			([:superClassOfClassDefiningTheMethod |				[:objself | 			Transcript show: 'I''am an Object';				cr]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #error		put: 			([:superClassOfClassDefiningTheMethod |				[:object :selector | 			Transcript show: 'Error: selector ' , selector printString , ' not understood';				cr.				Error signal]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #getIV		put: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #setIV		put: 			([:superClassOfClassDefiningTheMethod | [:object :iv :val | 			object at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #bar		put: 			([:superClassOfClassDefiningTheMethod | [:objself | 					5]] value: nil).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:13'!assemblePointClass	| cl |	cl := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (cl at: cl offsetForIVs) size.	pointClass at: 2 put: #ObjPoint.	pointClass at: 1 put: #ObjClass.	pointClass at: 4 put: #(#class #x #y).	pointClass at: 5 put: #(#x: #y:).	pointClass at: 3 put: #ObjObject.	pointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict) at: #x		put: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | [:objself | 			Transcript show: 'I''am a Point';				cr]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'ObjPoint>>foo';cr.				5				]] value: objectClass)! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assemblePointInstance	aPoint := Obj new: 3.	aPoint at: 1 put: #ObjPoint.	aPoint at: 2 put: 10.	aPoint at: 3 put: 15! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!setUp	"self new setUp"	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !!RawObjTest methodsFor: 'step3-tests-class access' stamp: 'StephaneDucasse 11/17/2014 11:09'!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (aPoint objClass = pointClass)! !!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjClassId	"(self selector: #testPrimitiveStructureObjClassId) run"	self assert: (pointClass objClassId = #ObjClass).! !!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjClassIdForSimpleObject	"self run: #testPrimitiveStructureObjClassIdForSimpleObject"	self assert: (aPoint objClassId = #ObjPoint).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjIVs	"(self selector: #testPrimitiveStructureObjIVs) run"	self assert: ((pointClass objIVs) = #(#class #x #y)).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) = #(#x: #y:)).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjMethodDict	"(self selector: #testPrimitiveStructureObjMethodDict) run"	self assert: ((pointClass objMethodDict) = nil) not! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjName	"(self selector: #testPrimitiveStructureObjName) run"	self assert: ((pointClass objName ) = #ObjPoint).	! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjSuperclassId	"(self selector: #testPrimitiveStructureObjSuperclassId) run"	self assert: ((pointClass objSuperclassId ) = #ObjObject).! !!Obj class methodsFor: 'bootstrap objMessage' stamp: 'StephaneDucasse 1/1/2018 20:14'!addMessagesForErrorHandling	"pre condition message has been created (and declared)"	"self addMessagesForErrorHandling"	| objMessage |	objMessage := self ObjMessage.	objMessage 		addUnaryMethod: #receiver 		withBody: 'objself valueOfInstanceVariable: #receiver'.	objMessage 		addUnaryMethod: #receiver2 		withBody: 'objself send: #getIV withArguments: #(#receiver)'.	objMessage 		addUnaryMethod: #selector 		withBody: 'objself send: #getIV withArguments: #(#selector)'.			objMessage 		addUnaryMethod: #arguments 		withBody: 'objself send: #getIV withArguments: #(#arguments)'.		objMessage 		addMethod: #setReceiver		args: 'receiver'		withBody:' objself send: #setIV withArguments: (Array with: #receiver with: receiver)'.			objMessage 		addMethod: #setSelector		args: 'selector'		withBody:' objself send: #setIV withArguments: (Array with: #selector with: selector)'.	objMessage 		addMethod: #setArguments		args: 'arguments'		withBody:' objself send: #setIV withArguments: (Array with: #arguments with: arguments)'.							^ objMessage ! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!bootstrap	"self bootstrap"		self initialize.	self manuallyCreateObjClass.	self createObjObject.	self createObjClass.! !!Obj class methodsFor: 'meta data' stamp: 'StephaneDucasse 1/1/2018 20:14'!classInstanceVariables	^ #(#class #name #superclass #iv #keywords #methodDict)! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!createObjClass	"self bootstrap"	| objClass |	objClass := self objClassStructure.	self defineAllocateMethodIn: objClass.	self defineNewMethodIn: objClass.	self defineInitializeMethodIn: objClass.	objClass 		addUnaryMethod: #isMetaclass		withBody: 'objself objIVs includes: #superclass'.		"an object is a class if is class is a metaclass. cool"		objClass 		addUnaryMethod: #isClass		withBody: 'objself objClass send: #isMetaclass withArguments:#()'.	^objClass! !!Obj class methodsFor: 'bootstrap objObject' stamp: 'StephaneDucasse 1/1/2018 20:14'!createObjObject	| objObject |	objObject := self objObjectStructure.	objObject addUnaryMethod: #class withBody: 'objself objClass'.	objObject addUnaryMethod: #isClass withBody: 'false'.	objObject addUnaryMethod: #isMetaclass withBody: 'false'. 	objObject 		addMethod: #error		args: 'arrayOfArguments'		withBody: 'Transcript show: ''error '', arrayOfArguments first.  ''error '', arrayOfArguments first'.	"some meta facilities"	objObject 		addMethod: #getIV		args: 'iv'		withBody: 'objself valueOfInstanceVariable: iv'.	objObject 		addMethod: #setIV		args: 'iv val'		withBody: 			' objself at: (objself offsetFromObjectOfInstanceVariable: iv) put: val'.	objObject 		addMethod: #initialize		args: 'initargs'		withBody: 'objself  initializeUsing: initargs'.	^objObject! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!declareClass: anObjClass 	"To declare an ObjClass in the class repository"	| nameC |	nameC := anObjClass objName.	nameC isNil		ifFalse: [definedObjClasses at: nameC put: anObjClass]		ifTrue: [self error: 'The class does not have a name']! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineAllocateMethodIn: class 	"The allocated obj method simply invokes the primitive allocateAnInstance."		class 		addUnaryMethod: #allocate 		withBody: 'objself allocateAnInstance'! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineInitializeMethodIn: objClass 	objClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'objself super: #initialize withArguments: {initArray} from: superClassOfClassDefiningTheMethod.			objself objIVs: (objself							computeNewIVFrom: (Obj giveClassNamed: objself objSuperclassId) objIVs							with: objself objIVs).			objself computeAndSetKeywords.			objself objMethodDict: IdentityDictionary new.			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineManualInitializeMethodIn: class 	class 		addMethod: #initialize		args: 'initArray'		withBody: 				'| objsuperclass |			objself initializeUsing: initArray.	"Initialize a class as an object. In the bootstrapped system will be done via super"			objsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].			objsuperclass isNil				ifFalse: 					[objself						objIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]				ifTrue: 					[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].			objself				objKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).			objself objMethodDict: (IdentityDictionary new: 3).			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineNewMethodIn: class 	class 		addMethod: #new		args: 'initArray'		withBody: 			'(objself send: #allocate withArguments: #()) send: #initialize withArguments: { initArray } '.! !!Obj class methodsFor: 'tricks' stamp: 'StephaneDucasse 1/1/2018 20:14'!doesNotUnderstand: aMessage	"debugging >>>  default shiftDown ifTrue:[ self halt ]."	"Sensor shiftPressed ifTrue:[ self halt ]."		^ definedObjClasses at: aMessage selector! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!giveClassNamed: aSymbol 	"Return the class defined in the class repository with the name aSymbol"	^ self giveClassNamed: aSymbol ifAbsent: [self error: ('The class ' , aSymbol printString , ' is not defined')]! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!giveClassNamed: aSymbol ifAbsent: aBlock	^ definedObjClasses at: aSymbol ifAbsent: aBlock! !!Obj class methodsFor: 'initialize' stamp: 'StephaneDucasse 1/1/2018 20:14'!initialize	"self initialize"	 	definedObjClasses := IdentityDictionary new.	definedObjClasses at: #ObjClass put: nil.	definedObjClasses at: #ObjObject put: nil.	definedObjClasses at: #ObjMessage put: nil.! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!manualObjClassStructure	| class |	class := Obj new: 6.	class objClassId: #ObjClass.	class objName: #ObjClass.	class objIVs: self classInstanceVariables.	class objKeywords: #(#name: #superclass: #iv: #keywords: #methodDict:).	class objSuperclassId: #ObjObject.	class objMethodDict: (IdentityDictionary new: 3).	^ class! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!manuallyCreateObjClass	"self manuallyCreateObjClass"	| class |	class := self manualObjClassStructure.	Obj declareClass: class.	self defineManualInitializeMethodIn: class.	self defineNewMethodIn: class.	self defineAllocateMethodIn: class.	^class! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassStructure	^(Obj giveClassNamed: #ObjClass) send: #new		withArguments: #(#(#name: #ObjClass #iv: #(#name #superclass #iv #keywords #methodDict) #superclass: #ObjObject))! !!Obj class methodsFor: 'bootstrap objMessage' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassStructureMessage	^ Obj ObjClass 		send: #new		withArguments: #(#(#name: #ObjMessage #iv: #(#receiver #selector #arguments) #superclass: #ObjObject))! !!Obj class methodsFor: 'bootstrap objObject' stamp: 'StephaneDucasse 1/1/2018 20:14'!objObjectStructure	^(Obj giveClassNamed: #ObjClass) 		send: #new		withArguments: #(#(#name: #ObjObject #iv: #(#class)))! !!Obj class methodsFor: 'skeleton metadata' stamp: 'StephaneDucasse 1/1/2018 20:14'!selectorsToSkeletonize	"Skeletonizer new 		selectors: Obj selectorsToSkeletonize;		sourceClassName: #Obj;		targetClassName: #ObjSkeleton;		installClass;		skeletonize		"	^ #(objIVs objIVs: objKeywords objKeywords: objMethodDict objMethodDict: objName objName: objSuperclassId objSuperclassId: objClass objClassId objClassId: allocateAnInstance offsetFromClassOfInstanceVariable: offsetFromObjectOfInstanceVariable: valueOfInstanceVariable: #send:withArguments: #super:withArguments:from: lookup: bodyOfMethod:)! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!addMethod: aSelector args: aString withBody: aStringBlock 	"Define a method with selector <aSelector> , having a string representing the arguments (ie 'aNumber aStream') 	and a string representing the method body in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  objMethodDict at: aSelector put: (self methodWithHeader: aString andBody: aStringBlock).	^self! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!addUnaryMethod: aSelector withBody: aStringBlock 	"Define a unary method with selector <aSelector> and a body <aaStringBlock> in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  addMethod: aSelector args: '' withBody: aStringBlock! !!Obj methodsFor: 'instance allocation' stamp: 'StephaneDucasse 1/1/2018 20:14'!allocateAnInstance	"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "	^ self! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!basicSend: selector withArguments: arguments from: aClass	"Execute the method found starting from aClass and whose name is selector."	"The core of the sending a message, reused for both a normal send or a super one."		| methodOrNil |	methodOrNil := aClass lookup: selector.	^ methodOrNil 		ifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ] 		ifNil: [ self sendError: selector withArgs: arguments ] ! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!blockArgsFrom: aCol	"self basicNew blockArgsFrom: ' abc def ghi '"			| col st |	col := aCol findTokens: Character space.	col := col copyWithout: ''.	st := ''.	col do: [ :each | st := st , ':', each ] separatedBy: [st := st, ' '].	^ st! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!bodyOfMethod: aSelector	"Return the method associated with the selector <aSelector> in the receiver.	Return nil if the selector is not defined.  self is an objClass"	^ self! !!Obj methodsFor: 'debugging' stamp: 'StephaneDucasse 1/1/2018 20:14'!classDebug	"(self giveClassNamed: #ObjClass) classDebug"	"(self giveClassNamed: #ObjSet) classDebug"	ObjClassInspector basicInspect: self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeAndSetKeywords	"Compute the keywords of a given class.  As the class of an object should not be changed.	 the keywords should note contain the keyword class. self is anObjClass"	self objKeywords: (self generateKeywords: (self objIVs copyWithout: #class))! !!Obj methodsFor: 'iv inheritance' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeNewIVFrom: superIVOrdCol with: localIVOrdCol	"Returns an ordered collection that is the union without duplicate of ivOfSuper and ivOrderedCollection.	Important the order of the instance variable is conserved"	| ivs |	^superIVOrdCol isNil 		ifTrue: [localIVOrdCol]		ifFalse: 			[ivs := superIVOrdCol asOrderedCollection copy.			localIVOrdCol do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!Obj methodsFor: 'iv inheritance' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeNewIVFromClass: anObjClass with: ivOrderedCollection 	"Obj computeNewIVFromClass: #(#C #C #O #(a b c d)) with: #(a z b t) asOrderedCollection"	| ivs |	^anObjClass isNil		ifTrue: [ivOrderedCollection]		ifFalse: 			[ivs := anObjClass objIVs asOrderedCollection copy.			ivOrderedCollection do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!doesUnderstand: aSelector 	"Tell if the receiver has a method having <aSelector> as selector. self is anObjClass"	^self objMethodDict keys includes: aSelector! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!generateKeywords: anArray 	"Returns an array containing the keywords made from the collection of Symbol passed as argument"	"self new generateKeywords: #(titi toto lulu) "	^anArray collect: [:e | (e , ':') asSymbol]! !!Obj methodsFor: 'instance initialization' stamp: 'StephaneDucasse 1/1/2018 20:14'!initializeUsing: anAlternatedArray 	"Returns the receiver an ObjObject initialized according to the directives given by anAlternateArray"	| ivValues |	ivValues := self 						returnValuesFrom: anAlternatedArray						followingSchema: self objClass objKeywords.	1 to:  ivValues size			do: [:i | self at: i + 1 put: (ivValues at: i)].	^ self ! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!keywordValue: aSymbol getFrom: anArray ifAbsent: aDefaultValue 	"precondition: ((length anArray) mod 2) = 0 	returns the value associated with the keyword represented by aSymbol 	in the initarg list represented by anArray."	"self new keywordValue: #titi getFrom: #(toto 12 titi 23) ifAbsent: 2"	"self new keywordValue: #titi getFrom: #(toto 23) ifAbsent: 2"	| i |	i := anArray indexOf: aSymbol ifAbsent: nil.	^i isNil 		ifTrue: [aDefaultValue] 		ifFalse: [anArray at: i + 1]! !!Obj methodsFor: 'method lookup' stamp: 'StephaneDucasse 1/1/2018 20:14'!lookup: selector	"look for the method named <selector> starting in the receiver. 	The lookup is done for a message sent to <anObjObject>. self is an objClass"	^ self! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!methodWithHeader: col andBody: aString 	| block string resBlock |	string := self stringOfBlockBodyFromHeader: col andBody: aString.	block := Compiler evaluate: string.	"bind superclass to the superclass of the class defining the method"	resBlock := block value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [666]).	^resBlock! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!numberOfIVs	"Returns the number of instance variables of the class an ObjClass"	^self objIVs size! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClass	"Receiver should be: anObjObject. Returns the class of the receiver (which is an ObjObject) and not its internal identification. Differs from classId  which is a primitive to access the structure representing a class"	^ self! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassId	"Receiver should be: anObjObject. Returns the identifier that identifies the class of the receiver (an objObject). In this implementation we chose to use the class name as identifier"	^ self! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassId: anObjClassId	"Receiver should be: anObjObject. Set the identifier that identifies the class of the receiver (anObjObject)."	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objIVs	"Receiver should be: anObjClass. Returns the list of instance variables"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objIVs: anOrderedCollection	"Receiver should be: anObjClass. Set the list of instance variable names of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objKeywords	"Receiver should be: anObjClass. Returns the keyword list of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objKeywords: anOrderedCollection	"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objMethodDict	"Receiver should be: anObjClass. Returns the method dictionary of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objMethodDict: aDictionary	"Receiver should be: anObjClass. Sets the method dictionary of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objName	"Receiver should be: anObjClass. Returns the name of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objName: aName	"Receiver should be: anObjClass. Set the name of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclass	"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"	^Obj giveClassNamed: self objSuperclassId! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclassId	"Receiver should be: anObjClass. Returns the superclass id of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclassId: anObjClassId	"Receiver should be: anObjClass. Set the superclass id of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'object structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForClass	^1! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForIVs	^4! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForKeywords	^5! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForMethodDict	^6! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForName	^2! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForSuperclass	^3! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetFromClassOfInstanceVariable: aSymbol	"Returns the index of the instance variable named aSymbol for an class anObjClass.	Returns 0 if the aSymbol is not present in the instance variable lists of anObjClass"	^ self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetFromObjectOfInstanceVariable: aSymbol	"Returns the offset of the instance variable named aSymbol in the object anObjObject.	If aSymbol is not an instance variable is not an instance variable of the object raise an error"	^ self! !!Obj methodsFor: 'printing' stamp: 'StephaneDucasse 1/1/2018 20:14'!printOn: aStream	aStream nextPutAll: 'an Obj object: '.		super printOn: aStream! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!removeMethod: aSelector	"Remove the method with aSelector <aSymbol> in the receiver. 	self is an objClass"	self objMethodDict removeKey: aSelector ifAbsent: [].	^self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!returnValuesFrom: anInitargArray followingSchema: anArrayOfKeywords 	"Return the values associated with the keys. The extracted values are taken from <anInitargArray> 	and the return values are extracted according to the schema defined by the collection of keys <anArrayOfKeywords>"	"self new returnValuesFrom: #(lulu 22  titi 35)  followingSchema: #(titi toto lulu titi)  #(35 nil 22 35)"	^anArrayOfKeywords collect: 			[:e | 			self keywordValue: e				getFrom: anInitargArray 				ifAbsent: nil]! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!send: selector withArguments: arguments	"send the message whose selector is <selector> to the receiver. The arguments of the messages are an array <arguments>. The method is lookep up in the class of the receiver. self is an objObject or a objClass."	^ self! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!sendError: selector withArgs: arguments	"send error wrapping arguments into an array with the selector as first argument. Instead of an array we should create a message object."		^ self send: #error withArguments:  {(arguments copyWithFirst: selector)}	! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!stringOfBlockBodyFromHeader: col andBody: aString 	^ '[ :superClassOfClassDefiningTheMethod |		[ :objself ' , (self blockArgsFrom: col) , ' |					 ' , aString , '] ]'! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!super: selector withArguments: arguments from: aSuperclass	"Invoke an oveeriden method named <selector> with an array of arguments <arguments>.  self is an objClass. aSuperclass should be the superclass of the class containing the method using super"	^ self! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!valueOfInstanceVariable: aSymbol	^ self! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!orderedStructure		^ orderedStructure! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!orderedStructure: anObject		orderedStructure := anObject! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!value	^ self host basicAt: (self orderedStructure indexOf: index)! !!ObjClassInspector methodsFor: 'list' stamp: 'StephaneDucasse 11/16/2014 23:10'!addVariableFields: elements		| classStructure |	classStructure := Obj classInstanceVariables.	classStructure do: [ :key |		elements add: (StrictlyOrderedEyeElement new 								orderedStructure: classStructure;								host: self object;								index: key; 								yourself)]! !"ObjVSkeleton"!"ObjVLispSkeleton"!!Obj methodsFor: 'object structure primitive' stamp: 'Anonymous 12/2/2024 15:06' prior: 33614835!objClassId	"Receiver should be: anObjObject. Returns the identifier that identifies the class of the receiver (an objObject). In this implementation we chose to use the class name as identifier"	^ self at: self offsetForClass		! !!Obj methodsFor: 'object structure primitive' stamp: 'Anonymous 12/2/2024 15:07' prior: 33615130!objClassId: anObjClassId	"Receiver should be: anObjObject. Set the identifier that identifies the class of the receiver (anObjObject)."	^ self at: self offsetForClass put: anObjClassId .! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:13' prior: 33616708!objName	"Receiver should be: anObjClass. Returns the name of the receiver (anObjClass)"	^ self at: self offsetForName .! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:16' prior: 33616895!objName: aName	"Receiver should be: anObjClass. Set the name of the receiver (anObjClass)"	^ self at: self offsetForName put: aName ! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:16' prior: 33617458!objSuperclassId	"Receiver should be: anObjClass. Returns the superclass id of the receiver (anObjClass)"	^ self at: self offsetForSuperclass .! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:17' prior: 33617662!objSuperclassId: anObjClassId	"Receiver should be: anObjClass. Set the superclass id of the receiver (anObjClass)"	^ self at: self offsetForSuperclass put: anObjClassId .! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:18' prior: 33617085!objSuperclass	"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"	^self giveClassNamed: self objSuperclassId! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:19' prior: 33624004!objSuperclass	"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"	^Obj  giveClassNamed: self objSuperclassId! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:20' prior: 33615365!objIVs	"Receiver should be: anObjClass. Returns the list of instance variables"	^ self at: self offsetForIVs! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:20' prior: 33615544!objIVs: anOrderedCollection	"Receiver should be: anObjClass. Set the list of instance variable names of the receiver (anObjClass)"	^ self at: self offsetForIVs put: anOrderedCollection .! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:22' prior: 33615973!objKeywords: anOrderedCollection	"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"	^ self at: self offsetForKeywords put: anOrderedCollection .! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:22' prior: 33616286!objMethodDict	"Receiver should be: anObjClass. Returns the method dictionary of the receiver (anObjClass)"	^ self at: self offsetForMethodDict .! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:23' prior: 33616492!objMethodDict: aDictionary	"Receiver should be: anObjClass. Sets the method dictionary of the receiver (anObjClass)"	^ self at: self offsetForMethodDict put: aDictionary .! !!RawObjTest methodsFor: 'step3-tests-class access' stamp: 'Anonymous 12/2/2024 15:24' prior: 33597890!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (pointClass objClassId = #ObjClass)! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'Anonymous 12/2/2024 15:30' prior: 33598858!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) ==#(#x: #y:)).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'Anonymous 12/2/2024 15:30' prior: 33626409!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) =#(#x: #y:)).! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:35' prior: 33625277!objKeywords: anOrderedCollection	"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"	^ self at: self offsetForKeywords put: anOrderedCollection.! !!Obj methodsFor: 'class structure primitive' stamp: 'Anonymous 12/2/2024 15:43' prior: 33615774!objKeywords	"Receiver should be: anObjClass. Returns the keyword list of the receiver (anObjClass)"	^ self at: self offsetForKeywords.! !!Obj methodsFor: 'object structure primitive' stamp: 'Anonymous 12/2/2024 15:53' prior: 33614508!objClass	"Receiver should be: anObjObject. Returns the class of the receiver (which is an ObjObject) and not its internal identification. Differs from classId  which is a primitive to access the structure representing a class"	^ Obj giveClassNamed: self objClassId .! !!Obj methodsFor: 'iv management' stamp: 'Anonymous 12/2/2024 16:19' prior: 33618510!offsetFromClassOfInstanceVariable: aSymbol	"Returns the index of the instance variable named aSymbol for an class anObjClass.	Returns 0 if the aSymbol is not present in the instance variable lists of anObjClass"	| listIV index |listIV := self objIVs .index := listIV indexOf: aSymbol .^ index ifNotNil: [ index ] ifNil: [ 0 ].! !!Obj methodsFor: 'keyword management' stamp: 'Anonymous 12/2/2024 16:24' prior: 33618815!offsetFromObjectOfInstanceVariable: aSymbol	"Returns the offset of the instance variable named aSymbol in the object anObjObject.	If aSymbol is not an instance variable is not an instance variable of the object raise an error"	| offset |offset := self objClass offsetFromClassOfInstanceVariable:aSymbol .offset = 0 ifTrue:[ ^ self error: 'Variable dinstance non definie: ',aSymbol asString ].^ offset! !!Obj methodsFor: 'iv management' stamp: 'Anonymous 12/2/2024 16:30' prior: 33621396!valueOfInstanceVariable: aSymbol	^ self valueOfInstanceVariable: aSymbol! !!Obj methodsFor: 'instance allocation' stamp: 'Anonymous 12/2/2024 16:35' prior: 33609258!allocateAnInstance	"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "	   "Alloue une nouvelle instance de la classe actuelle"    ^ Array with: self name with: nil with: nil.! !!Obj methodsFor: 'instance allocation' stamp: 'Anonymous 12/2/2024 16:37' prior: 33628992!allocateAnInstance    "Retourne une nouvelle instance de la classe avec ses variables d'instance initialisées à nil."        | instanceSize newInstance |        instanceSize := self ivs size + 1. "Taille de l'instance = 1 pour le nom de la classe + variables d'instance"    newInstance := Array new: instanceSize. "Crée un tableau de la taille appropriée"        newInstance at: 1 put: self name. "Le premier élément est le nom de la classe"        ^ newInstance! !!Obj methodsFor: 'instance allocation' stamp: 'Anonymous 12/2/2024 16:38' prior: 33629355!allocateAnInstance	"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "	   "Alloue une nouvelle instance de la classe actuelle"    ^self! !!Obj methodsFor: 'instance allocation' stamp: 'Anonymous 12/2/2024 16:43' prior: 33629929!allocateAnInstance    "Créer une nouvelle instance de la classe actuelle avec ses variables d'instance initialisées à nil"        | instanceSize newInstance |        "1. Calculer la taille de l'instance"    instanceSize := self ivs size + 1.        "2. Créer un tableau vide de cette taille"    newInstance := Array new: instanceSize.        "3. Ajouter l'identifiant de la classe comme premier élément"    newInstance at: 1 put: self name.        "4. Retourner cette nouvelle instance"    ^ newInstance! !!Obj methodsFor: 'instance allocation' stamp: 'Anonymous 12/2/2024 16:44' prior: 33630253!allocateAnInstance    "Créer une nouvelle instance de la classe actuelle avec ses variables d'instance initialisées à nil"    ^self! !!Obj methodsFor: 'instance allocation' stamp: 'Anonymous 12/2/2024 16:48' prior: 33630873!allocateAnInstance    "Créer une nouvelle instance de la classe actuelle avec ses variables d'instance initialisées à nil"        | instanceSize newInstance |        "1. Calculer la taille de l'instance"    instanceSize := self objIVs  size + 1.        "2. Créer un tableau vide de cette taille"    newInstance := Array new: instanceSize.        "3. Ajouter l'identifiant de la classe comme premier élément"    newInstance at: 1 put: self name.        "4. Retourner cette nouvelle instance"    ^ newInstance! !!Obj methodsFor: 'instance allocation' stamp: 'Anonymous 12/2/2024 16:49' prior: 33631105!allocateAnInstance    "Créer une nouvelle instance de la classe actuelle avec ses variables d'instance initialisées à nil"        | instanceSize newInstance |        "1. Calculer la taille de l'instance"    instanceSize := self objIVs  size + 1.        "2. Créer un tableau vide de cette taille"    newInstance := Array new: instanceSize.        "3. Ajouter l'identifiant de la classe comme premier élément"    newInstance at: 1 put: self objName .        "4. Retourner cette nouvelle instance"    ^ newInstance! !!Obj methodsFor: 'instance allocation' stamp: 'Anonymous 12/2/2024 16:55' prior: 33631729!allocateAnInstance    | instanceSize newInstance |        instanceSize := self objIVs size + 1.    Transcript show: 'Instance size: ', instanceSize printString; cr.        newInstance := Array new: instanceSize.    newInstance at: 1 put: self objName.    Transcript show: 'New instance: ', newInstance printString; cr.        ^ newInstance! !!Obj methodsFor: 'instance allocation' stamp: 'Anonymous 12/2/2024 16:57' prior: 33632357!allocateAnInstance    "Créer une nouvelle instance de la classe actuelle avec ses variables d'instance initialisées à nil"    | instanceSize newInstance |        "1. Calculer la taille de l'instance : nombre de variables d'instance + 1 (pour l'identifiant de classe)"    instanceSize := self objIVs size + 1.    "2. Créer un tableau vide de cette taille"    newInstance := Array new: instanceSize.    "3. Ajouter l'identifiant de la classe (le nom de la classe) comme premier élément"    newInstance at: 1 put: self objName.    "4. Initialiser toutes les variables d'instance à nil"    2 to: instanceSize do: [:index | newInstance at: index put: nil].    "5. Retourner l'instance nouvellement créée"    ^ newInstance! !!Obj methodsFor: 'instance allocation' stamp: 'Anonymous 12/2/2024 17:05' prior: 33632802!allocateAnInstance    "Créer une nouvelle instance de la classe actuelle avec ses variables d'instance initialisées à nil"    |newInstance |newInstance:= Obj new:( self numberOfIVs).newInstance objClassId:(self objName).^newInstance       ! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:21' prior: 33610347!bodyOfMethod: aSelector	"Return the method associated with the selector <aSelector> in the receiver.	Return nil if the selector is not defined.  self is an objClass"	^ self objMethodDict at: aSelector ifAbsent: [ nil ]! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:23' prior: 33633985!bodyOfMethod: aSelector	"Return the method associated with the selector <aSelector> in the receiver.	Return nil if the selector is not defined.  self is an objClass"	 (self doesUnderstand: aSelector)        ifTrue: [^ self methodDictionary at: aSelector]        ifFalse: [^ nil].! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:23' prior: 33634300!bodyOfMethod: aSelector	"Return the method associated with the selector <aSelector> in the receiver.	Return nil if the selector is not defined.  self is an objClass"	 (self doesUnderstand: aSelector)        ifTrue: [^ self method at: aSelector]        ifFalse: [^ nil].! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:24' prior: 33634678!bodyOfMethod: aSelector	"Return the method associated with the selector <aSelector> in the receiver.	Return nil if the selector is not defined.  self is an objClass"(self doesUnderstand: aSelector)        ifTrue: [^ self methodDictionary at: aSelector]        ifFalse: [^ nil].! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:25' prior: 33635046!bodyOfMethod: aSelector	"Return the method associated with the selector <aSelector> in the receiver.	Return nil if the selector is not defined.  self is an objClass"^self objMethodDict at: aSelector ifAbsent: [ nil ]! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:28' prior: 33635421!bodyOfMethod: aSelector    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n'existe pas."        | method |        "Vérifier si la méthode est dans le dictionnaire des méthodes"    method := self methodDictionary at: aSelector ifAbsent: [nil].        "Retourner le bloc de la méthode"    ^ method.! !!ObjTest methodsFor: 'setup' stamp: 'Anonymous 12/2/2024 17:33' prior: 33569608!setUp	"self new setUp"   Compiler := OpalCompiler.	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:35' prior: 33635733!bodyOfMethod: aSelector    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n'existe pas."   ^self objMethodDict at: aSelector ifAbsent: [ nil ]! !!Obj methodsFor: 'method management' stamp: 'AutoDeprecationRefactoring 12/2/2024 17:35' prior: 33613900!methodWithHeader: col andBody: aString	| block string resBlock |	string := self stringOfBlockBodyFromHeader: col andBody: aString.	block := Compiler new		source: string;		evaluate.	"bind superclass to the superclass of the class defining the method"	resBlock := block		value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [ 666 ]).	^ resBlock! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:38' prior: 33636588!bodyOfMethod: aSelector    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n'existe pas."   ^self objMethodDict at: aSelector ifAbsent: [ 	self error: 'Method non trouvé : ', aSelector asString  ].! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:44' prior: 33637334!bodyOfMethod: aSelector     "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n'existe pas."   ^self objMethodDict at: aSelector .! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:47' prior: 33637668!bodyOfMethod: aSelector     "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n'existe pas."   ^self objMethodDict at: aSelector ! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:49' prior: 33637931!bodyOfMethod: args1     "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n'existe pas."   ^self objMethodDict at: args1 ! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:53' prior: 33638193!bodyOfMethod: aSelector    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n'existe pas."    ^self objMethodDict at: aSelector ifAbsent: [nil].! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:55' prior: 33638447!bodyOfMethod: aSelector    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n'existe pas."    ^ self objMethodDict at: aSelector .! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 17:59' prior: 33638726!bodyOfMethod: aSelector    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n'existe pas."    ^ self objMethodDict at: aSelector ifAbsent: [ nil ] .! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 18:17' prior: 33638991!bodyOfMethod: aSelector    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n'existe pas."    ^ self objMethodDict at: aSelector ifAbsent: [ nil ] ! !!Obj methodsFor: 'method lookup' stamp: 'Anonymous 12/2/2024 18:25' prior: 33613649!lookup: selector	"look for the method named <selector> starting in the receiver. 	The lookup is done for a message sent to <anObjObject>. self is an objClass"| method superclassid |method := self objMethodDict at: selector ifAbsent: [ nil ].method ifNil:[ superclassid := self objSuperclassId .superclassidifNil: [ ^ nil ]ifNotNil: [ ^ self objSuperclass lookup: selector ] ]ifNotNil: [ ^ method . ]! !!Obj methodsFor: 'method management' stamp: 'Anonymous 12/2/2024 18:30' prior: 33639274!bodyOfMethod: aSelector    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n'existe pas."    ^ self objMethodDict at: aSelector ifAbsent: [ 	self error: 'Methode non trouvée', aSelector asString 		 ]. ! !!Obj methodsFor: 'iv management' stamp: 'Anonymous 12/2/2024 18:35' prior: 33628824!valueOfInstanceVariable: aSymbol|offset|offset:= self offsetFromObjectOfInstanceVariable: aSymbol.	^ self  basicAt: offset.! !!Obj methodsFor: 'message passing' stamp: 'Anonymous 12/2/2024 18:37' prior: 33621058!super: selector withArguments: arguments from: aSuperclass	"Invoke an oveeriden method named <selector> with an array of arguments <arguments>.  self is an objClass. aSuperclass should be the superclass of the class containing the method using super"	^ self basicSend: selector withArguments: arguments from:aSuperclass .! !!Obj methodsFor: 'message passing' stamp: 'Anonymous 12/2/2024 18:40' prior: 33620129!send: selector withArguments: arguments^ self basicSend: selector withArguments: arguments from: selfobjClass .! !----SNAPSHOT----2024-12-02T18:59:43.082187+01:00 project.image priorSource: 100!!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'Anonymous 12/2/2024 22:10' prior: 33604048!defineManualInitializeMethodIn: objClass 	objClass	addMethod: #initialize	args: 'initArray'	withBody:		'objself super: #initialize withArguments: {initArray} from:		superClassOfClassDefiningTheMethod.		objself objIVs: (objself			computeNewIVFrom:				(Obj giveClassNamed: objself objSuperclassId) objIVs			with: objself objIVs).		objself computeAndSetKeywords.		objself objMethodDict: IdentityDictionary new.		Obj declareClass: objself.		objself'! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'Anonymous 12/2/2024 22:12' prior: 33603483!defineInitializeMethodIn:  class  	class 		addMethod: #initialize		args: 'initArray'		withBody: 				'| objsuperclass |			objself initializeUsing: initArray.	"Initialize a class as an object. In the bootstrapped system will be done via super"			objsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].			objsuperclass isNil				ifFalse: 					[objself						objIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]				ifTrue: 					[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].			objself				objKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).			objself objMethodDict: (IdentityDictionary new: 3).			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'Anonymous 12/2/2024 22:15' prior: 33641332!defineManualInitializeMethodIn: class 	class 		addMethod: #initialize		args: 'initArray'		withBody: 				'| objsuperclass |			objself initializeUsing: initArray.	"Initialize a class as an object. In the bootstrapped system will be done via super"			objsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].			objsuperclass isNil				ifFalse: 					[objself						objIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]				ifTrue: 					[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].			objself				objKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).			objself objMethodDict: (IdentityDictionary new: 3).			Obj declareClass: objself.			objself'! !!Obj methodsFor: 'iv management' stamp: 'Anonymous 12/6/2024 15:00' prior: 33627898!offsetFromClassOfInstanceVariable: aSymbol	"Returns the index of the instance variable named aSymbol for an class anObjClass.	Returns 0 if the aSymbol is not present in the instance variable lists of anObjClass"	| listIV index |listIV := self objIVs .index := listIV indexOf: aSymbol .index := (listIV indexOf: aSymbol) = 0 ifTrue: [0] ifFalse: [index].^ index ifNotNil: [ index ] ifNil: [ 0 ].! !