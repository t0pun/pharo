OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T14:46:11.215187+01:00' ],		#prior : OmReference [ 'Pharo8.0-SNAPSHOT-32bit-0932da8.nnxffz9etkd9gqf7tutp9uo1', '8321' ],		#self : OmReference [ '1' ]	},	#content : EpMonticelloVersionsLoad {		#versionNames : OrderedCollection [			'ObjVSkeleton-stephane.ducasse.6'		]	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T14:46:22.070187+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMonticelloVersionsLoad {		#versionNames : OrderedCollection [			'ObjVLispSkeleton-StephaneDucasse.6'		]	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ],		#time : DateAndTime [ '2024-12-02T14:46:22.210187+01:00' ],		#trigger : @3	},	#content : EpCategoryAddition {		#classCategoryName : #ObjVSkeleton-AdvancedTests,		#affectedPackageName : #ObjVSkeleton	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ],		#time : DateAndTime [ '2024-12-02T14:46:22.357187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'TestCase variableSubclass: #ObjExampleTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'ObjVSkeleton-AdvancedTests\'',				#superclassName : 'TestCase',				#traitCompositionSource : '{}'			},			#name : #ObjExampleTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'ObjExampleTest class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'ObjExampleTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ObjExampleTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ObjVSkeleton-AdvancedTests,			#package : #ObjVSkeleton,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ],		#time : DateAndTime [ '2024-12-02T14:46:22.387187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpCategoryAddition {		#classCategoryName : #ObjVSkeleton-Experimental,		#affectedPackageName : #ObjVSkeleton	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ],		#time : DateAndTime [ '2024-12-02T14:46:22.392187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'TestCase subclass: #ObjMessageTest\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'ObjVSkeleton-Experimental\'',				#superclassName : 'TestCase',				#traitCompositionSource : '{}'			},			#name : #ObjMessageTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'ObjMessageTest class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'ObjMessageTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ObjMessageTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ObjVSkeleton-Experimental,			#package : #ObjVSkeleton,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ],		#time : DateAndTime [ '2024-12-02T14:46:22.394187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpCategoryAddition {		#classCategoryName : #ObjVSkeleton,		#affectedPackageName : #ObjVSkeleton	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ],		#time : DateAndTime [ '2024-12-02T14:46:22.396187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'TestCase subclass: #ObjTest\r\tinstanceVariableNames: \'objectClass aPoint coloredPointClass pointClass classClass aColoredPoint aIncrementalColoredPoint incrementalColoredPointClass\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'ObjVSkeleton\'',				#superclassName : 'TestCase',				#traitCompositionSource : '{}'			},			#name : #ObjTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ObjTest,						#isMetaSide : false					},					#name : #objectClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ObjTest,						#isMetaSide : false					},					#name : #aPoint,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ObjTest,						#isMetaSide : false					},					#name : #coloredPointClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ObjTest,						#isMetaSide : false					},					#name : #pointClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ObjTest,						#isMetaSide : false					},					#name : #classClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ObjTest,						#isMetaSide : false					},					#name : #aColoredPoint,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ObjTest,						#isMetaSide : false					},					#name : #aIncrementalColoredPoint,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ObjTest,						#isMetaSide : false					},					#name : #incrementalColoredPointClass,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'ObjTest class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'ObjTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ObjTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ObjVSkeleton,			#package : #ObjVSkeleton,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ],		#time : DateAndTime [ '2024-12-02T14:46:22.404187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'TestCase subclass: #ObjTestBootstrap\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'ObjVSkeleton-AdvancedTests\'',				#superclassName : 'TestCase',				#traitCompositionSource : '{}'			},			#name : #ObjTestBootstrap,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'ObjTestBootstrap class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'ObjTestBootstrap class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ObjTestBootstrap,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ObjVSkeleton-AdvancedTests,			#package : #ObjVSkeleton,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ],		#time : DateAndTime [ '2024-12-02T14:46:22.410187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'TestCase subclass: #RawObjTest\r\tinstanceVariableNames: \'objectClass aPoint coloredPointClass pointClass classClass aColoredPoint aIncrementalColoredPoint incrementalColoredPointClass\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'ObjVSkeleton\'',				#superclassName : 'TestCase',				#traitCompositionSource : '{}'			},			#name : #RawObjTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #objectClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #aPoint,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #coloredPointClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #pointClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #classClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #aColoredPoint,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #aIncrementalColoredPoint,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #incrementalColoredPointClass,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'RawObjTest class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'RawObjTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RawObjTest,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ObjVSkeleton,			#package : #ObjVSkeleton,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ],		#time : DateAndTime [ '2024-12-02T14:46:22.413187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'TestCase subclass: #RawObjTest\r\tinstanceVariableNames: \'objectClass aPoint coloredPointClass pointClass classClass aColoredPoint aIncrementalColoredPoint incrementalColoredPointClass\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'ObjVSkeleton\'',				#superclassName : 'TestCase',				#traitCompositionSource : '{}'			},			#name : #RawObjTest,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #objectClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #aPoint,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #coloredPointClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #pointClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #classClass,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #aColoredPoint,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #aIncrementalColoredPoint,					#parent : @8				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #RawObjTest,						#isMetaSide : false					},					#name : #incrementalColoredPointClass,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'RawObjTest class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'RawObjTest class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #RawObjTest,					#isMetaSide : false				},				#parent : @8,				#content : 'These tests are based on a setup that does not rely on structure for the accessors.',				#stamp : 'StephaneDucasse 11/17/2014 11:09'			},			#classVariables : OrderedCollection [ ],			#category : #ObjVSkeleton,			#package : #ObjVSkeleton,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'These tests are based on a setup that does not rely on structure for the accessors.',		#newStamp : 'StephaneDucasse 11/17/2014 11:09'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ],		#time : DateAndTime [ '2024-12-02T14:46:22.416187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Array variableSubclass: #Obj\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'ObjVSkeleton\'',				#superclassName : 'Array',				#traitCompositionSource : '{}'			},			#name : #Obj,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Obj class\r\tinstanceVariableNames: \'definedObjClasses\'',					#traitCompositionSource : '{}'				},				#name : #'Obj class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Obj class',							#isMetaSide : true						},						#name : #definedObjClasses,						#parent : @13					}				],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Obj,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ObjVSkeleton,			#package : #ObjVSkeleton,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ],		#time : DateAndTime [ '2024-12-02T14:46:22.424187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpCategoryAddition {		#classCategoryName : #ObjVSkeleton-Inspector,		#affectedPackageName : #ObjVSkeleton	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ],		#time : DateAndTime [ '2024-12-02T14:46:22.428187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'BasicIndexedEyeElement variableSubclass: #StrictlyOrderedEyeElement\r\tinstanceVariableNames: \'orderedStructure\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'ObjVSkeleton-Inspector\'',				#superclassName : 'BasicIndexedEyeElement',				#traitCompositionSource : '{}'			},			#name : #StrictlyOrderedEyeElement,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #StrictlyOrderedEyeElement,						#isMetaSide : false					},					#name : #orderedStructure,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'StrictlyOrderedEyeElement class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'StrictlyOrderedEyeElement class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #StrictlyOrderedEyeElement,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ObjVSkeleton-Inspector,			#package : #ObjVSkeleton,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ],		#time : DateAndTime [ '2024-12-02T14:46:22.432187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'EyeCollectionInspector variableSubclass: #ObjClassInspector\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'ObjVSkeleton-Inspector\'',				#superclassName : 'EyeCollectionInspector',				#traitCompositionSource : '{}'			},			#name : #ObjClassInspector,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'ObjClassInspector class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'ObjClassInspector class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ObjClassInspector,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #ObjVSkeleton-Inspector,			#package : #ObjVSkeleton,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ],		#time : DateAndTime [ '2024-12-02T14:46:22.434187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'EyeCollectionInspector variableSubclass: #ObjClassInspector\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'ObjVSkeleton-Inspector\'',				#superclassName : 'EyeCollectionInspector',				#traitCompositionSource : '{}'			},			#name : #ObjClassInspector,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'ObjClassInspector class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'ObjClassInspector class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ObjClassInspector,					#isMetaSide : false				},				#parent : @8,				#content : 'I\'m a simple inspector that can inspect fixed structured Obj class.\r\r"creating class by hand"\r\r| coloredPointClass |\rcoloredPointClass := Obj new: 6.\rcoloredPointClass at: coloredPointClass offsetForName put: #ObjColoredPoint.\rcoloredPointClass at: coloredPointClass offsetForClass put: #ObjClass.\rcoloredPointClass at: coloredPointClass offsetForIVs put: #( #class #x #y #color).\rcoloredPointClass at: coloredPointClass offsetForSuperclass put: #ObjPoint.\rcoloredPointClass at: coloredPointClass offsetForMethodDict\tput: (IdentityDictionary new).\rcoloredPointClass.\r\rObjClassInspector basicInspect: coloredPointClass.\r\r',				#stamp : 'StephaneDucasse 11/16/2014 23:11'			},			#classVariables : OrderedCollection [ ],			#category : #ObjVSkeleton-Inspector,			#package : #ObjVSkeleton,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I\'m a simple inspector that can inspect fixed structured Obj class.\r\r"creating class by hand"\r\r| coloredPointClass |\rcoloredPointClass := Obj new: 6.\rcoloredPointClass at: coloredPointClass offsetForName put: #ObjColoredPoint.\rcoloredPointClass at: coloredPointClass offsetForClass put: #ObjClass.\rcoloredPointClass at: coloredPointClass offsetForIVs put: #( #class #x #y #color).\rcoloredPointClass at: coloredPointClass offsetForSuperclass put: #ObjPoint.\rcoloredPointClass at: coloredPointClass offsetForMethodDict\tput: (IdentityDictionary new).\rcoloredPointClass.\r\rObjClassInspector basicInspect: coloredPointClass.\r\r',		#newStamp : 'StephaneDucasse 11/16/2014 23:11'	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ],		#time : DateAndTime [ '2024-12-02T14:46:22.725187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ObjExampleTest class',				#isMetaSide : true			},			#name : #setMetaclassDefinition,			#protocol : #'first user-defined metaclasses',			#sourceCode : 'setMetaclassDefinition\r\t"self setMetaclassDefinition"\r\r\t| setClass |\r\tsetClass := Obj ObjClass\r\t\t\t\tsend: #new\r\t\t\t\twithArguments: #(#(#name: #ObjSet #iv: #(#myInstances) #superclass: #ObjClass)).\t"initialize on a metaclass"\r\tsetClass \r\t\taddMethod: #initialize\r\t\targs: \'initArray\'\r\t\twithBody: \r\t\t\t\'\r\t\t\tobjself binarySuper: #initialize with: initArray from: superClassOfClassDefiningTheMethod.\r\t\t\tobjself send: #setIV\r\t\t\t\twithArguments: (Array with: #myInstances with: OrderedCollection new).\r\t\t\tobjself\'.\r\r\tsetClass addUnaryMethod: #instances\r\t\twithBody: \'objself binarySend: #getIV with: #myInstances\'.\r\r\tsetClass addMethod: #new\r\t\targs: \'initArray\'\r\t\twithBody: \r\t\t\t\'| newInst others |\r\t\t\tnewInst := objself super: #new withArguments: (Array with: initArray) from: superClassOfClassDefiningTheMethod.\r\t\t\tothers := objself unarySend: #instances.\r\t\t\tothers := others add: newInst;\r\t\t\t\t\t\tyourself.\r\t\t\tobjself send: #setIV withArguments: (Array with: #myInstances with: others).\r\t\t\tnewInst\'',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ],		#time : DateAndTime [ '2024-12-02T14:46:22.726187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ObjExampleTest class',				#isMetaSide : true			},			#name : #setMetaclassExample,			#protocol : #'first user-defined metaclasses',			#sourceCode : 'setMetaclassExample\r\t"self setMetaclassExample"\r\r\t| memoPointClass |\r\tself setMetaclassDefinition.\r\tmemoPointClass := Obj ObjSet \r\t\t\t\t\t\tsend: #new\r\t\t\t\t\t\twithArguments: #(#(#name: #ObjMemoPoint  #iv: #() #superclass: #ObjPoint)).\r\tmemoPointClass send: #new withArguments: #(#(#x: 24 #y: 6)).\r\tmemoPointClass send: #new withArguments: #(#(#x: 15 #y: 10)).\r\t^memoPointClass send: #instances withArguments: #().',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ],		#time : DateAndTime [ '2024-12-02T14:46:22.727187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjExampleTest,				#isMetaSide : false			},			#name : #abstractMetaclassDefinition,			#protocol : #setup,			#sourceCode : 'abstractMetaclassDefinition\r \r\t(Obj giveClassNamed: #ObjClass)\r\t\t\t\t\t \t\tsend: #new\r\t\t\t\t\t\t\twithArguments: #(#(#name: #ObjAbstractClass #iv: #() #superclass: #ObjClass)).\r\tObj ObjAbstractClass \r\t\taddMethod: #new\r\t\targs: \'initArray\'\r\t\twithBody: \r\t\t\t\' objself error: \'\' the class \'\' , objself objName asString , \'\' is abstract\'\'\'',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ],		#time : DateAndTime [ '2024-12-02T14:46:22.728187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjExampleTest,				#isMetaSide : false			},			#name : #defineObjAbstractPoint,			#protocol : #setup,			#sourceCode : 'defineObjAbstractPoint\r\r\t(Obj ObjAbstractClass)\r\t\tsend: #new\r\t\twithArguments: #(#(#name: #ObjAbstractPoint #iv: #() #superclass: #ObjObject)).\r\tObj ObjAbstractPoint\r\t\taddUnaryMethod: #givex\r\t\twithBody: \'objself  valueOfInstanceVariable: #x \'.\r\tObj ObjAbstractPoint \r\t\taddUnaryMethod: #display\r\t\twithBody: \r\t\t\t\'Transcript cr;\r\t\t\t\tshow: \'\'aPoint with x = \'\'.\r\t\t\tTranscript show: (objself send: #givex withArguments: #()) printString;\r\t\t\t\tcr\'.',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ],		#time : DateAndTime [ '2024-12-02T14:46:22.729187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjExampleTest,				#isMetaSide : false			},			#name : #defineObjPoint,			#protocol : #setup,			#sourceCode : 'defineObjPoint\r\tObj ObjClass send: #new\r\t\twithArguments: #(#(#name: #ObjPoint #iv: #(#x #y) #superclass: #ObjAbstractPoint)).',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ],		#time : DateAndTime [ '2024-12-02T14:46:22.729187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjExampleTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #setup,			#sourceCode : 'setUp\r\r\tObj bootstrap.\r\tself abstractMetaclassDefinition.\r\tself defineObjAbstractPoint.\r\tself defineObjPoint',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ],		#time : DateAndTime [ '2024-12-02T14:46:22.729187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjExampleTest,				#isMetaSide : false			},			#name : #testAbstractMetaclassExample,			#protocol : #'test abstract',			#sourceCode : 'testAbstractMetaclassExample\r\r\tself should: [Obj ObjAbstractClass send: #new withArguments: #(#(#x: 24 #y: 6))] raise: Error.',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ],		#time : DateAndTime [ '2024-12-02T14:46:22.730187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjExampleTest,				#isMetaSide : false			},			#name : #testAbstractMetaclassExampleWithConcreteSubclass,			#protocol : #'test abstract',			#sourceCode : 'testAbstractMetaclassExampleWithConcreteSubclass\r\r\tself shouldnt: [Obj ObjPoint send: #new withArguments: #(#(#x: 24 #y: 6))]\r\t\traise: Error',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ],		#time : DateAndTime [ '2024-12-02T14:46:22.730187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjExampleTest,				#isMetaSide : false			},			#name : #testColoredPoint,			#protocol : #'test abstract',			#sourceCode : 'testColoredPoint\r\r\t| coloredPointClass aColoredPoint |\r\tcoloredPointClass := (Obj ObjClass)\r\t\t\t\t\t\t \tsend: #new \r\t\t\t\t\t\t\twithArguments: #((#name: #ObjColoredPoint \r\t\t\t\t\t\t\t           \t\t   #iv: #(#color) \r\t\t\t\t\t\t\t            \t  #superclass: #ObjPoint)).\r\r\taColoredPoint := coloredPointClass send: #new withArguments: #((#x: 24 #y: 6 #color: #blue)).\t\r\t"first messages sent"\r\r\tself assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 24.\r\taColoredPoint send: #setIV withArguments: #(#x 25).\r\tself assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 25.\r\r\tself assert: (aColoredPoint send: #getIV withArguments: #(#color)) = #blue.\t\r\r\t"adding some methods"\r\r\tcoloredPointClass \r\t\taddUnaryMethod: #giveColor\r\t\twithBody: \'objself send: #getIV withArguments: #(#color)\'.\r\r\tcoloredPointClass \r\t\taddMethod: #setColor\r\t\targs: \'col\'\r\t\twithBody:\' objself send: #setIV withArguments: (Array with: #color with: col)\'.\r\r\tcoloredPointClass addUnaryMethod: #display\r\t\twithBody:  \r\t\t\t\'objself super: #display withArguments: #() from: superClassOfClassDefiningTheMethod.\r\t\t\tTranscript cr;\r\t\t\t\tshow: \'\' with Color = \'\'.\r\t\t\tTranscript show: (objself send: #giveColor withArguments: #()) printString;\r\t\t\t\tcr\'.\r\tself assert: (aColoredPoint send: #giveColor withArguments: #()) = #blue.\r\t\r\tself assert: (aColoredPoint send: #givex withArguments: #()) = 25.\r\t\r\taColoredPoint send: #display withArguments: #().',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ],		#time : DateAndTime [ '2024-12-02T14:46:22.730187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjMessageTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #setup,			#sourceCode : 'setUp\r\r\tObj bootstrap.\r\tObj objClassStructureMessage.',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ],		#time : DateAndTime [ '2024-12-02T14:46:22.731187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjMessageTest,				#isMetaSide : false			},			#name : #testMessageClassMethods,			#protocol : #tests,			#sourceCode : 'testMessageClassMethods\r\t"self debug: #testMessageClassMethods"\r\t\r\t| msg |\r\tObj addMessagesForErrorHandling.\r\tmsg := Obj ObjMessage \r\t\t\t\tsend: #new \r\t\t\t\twithArguments: #(#(#receiver: 24 #selector: #factorial)).\r\t\r\tself assert: (msg send: #receiver2 withArguments: #()) equals: 24.\r\tself assert: (msg send: #receiver withArguments: #()) equals: 24.\r\tself assert: (msg send: #selector withArguments: #()) equals: #factorial.\r\t\r\tmsg := Obj ObjMessage \r\t\tsend: #new \r\t\twithArguments: #(#(#receiver: 24 #selector: #+ arguments: #(25))).\r\tself assert: (msg send: #arguments withArguments: #())  equals: #(25).\r\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ],		#time : DateAndTime [ '2024-12-02T14:46:22.731187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjMessageTest,				#isMetaSide : false			},			#name : #testMessageClassMethodsDefined,			#protocol : #tests,			#sourceCode : 'testMessageClassMethodsDefined\r\t"self debug: #testMessageClassMethodsDefined"\r\t\r\t| msg |\r\tObj addMessagesForErrorHandling.\r\tself deny: Obj ObjMessage objMethodDict size isZero\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ],		#time : DateAndTime [ '2024-12-02T14:46:22.731187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjMessageTest,				#isMetaSide : false			},			#name : #testMessageClassStructureDeclared,			#protocol : #tests,			#sourceCode : 'testMessageClassStructureDeclared\r\r\tObj objClassStructureMessage.\r\tself assert: Obj ObjMessage objName = #ObjMessage.\r\tself assert: Obj ObjMessage objClass objName= #ObjClass.\r\tself assert: Obj ObjMessage objIVs asArray = #(#class #receiver #selector #arguments).\r\tself assert: Obj ObjMessage objSuperclass = Obj ObjObject\r\t',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ],		#time : DateAndTime [ '2024-12-02T14:46:22.731187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjMessageTest,				#isMetaSide : false			},			#name : #testUsingPrimitivesMessageClassMethods,			#protocol : #tests,			#sourceCode : 'testUsingPrimitivesMessageClassMethods\r\r\t| msg |\r\tmsg := Obj ObjMessage \r\t\tsend: #new \r\t\twithArguments: #(#(#receiver: 24 #selector: #factorial)).\r\t\r\tself assert: (msg at: 1) equals: #ObjMessage.\r\tself assert: (msg at: 2) equals: 24.\r\tself assert: (msg at: 3) equals: #factorial.\r\t\r\tmsg := Obj ObjMessage \r\t\tsend: #new \r\t\twithArguments: #(#(#receiver: 24 #selector: #+ arguments: #(25))).\r\tself assert: (msg at: 4)  equals: #(25).',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ],		#time : DateAndTime [ '2024-12-02T14:46:22.732187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #assembleClassClass,			#protocol : #setup,			#sourceCode : 'assembleClassClass\r\tclassClass := Obj new: 6.\r\tclassClass at: classClass offsetForName put: #ObjClass.\r\tclassClass at: classClass offsetForClass put: #ObjClass.\r\tclassClass at: classClass offsetForIVs\r\t\tput: #(#class #name #superclass #iv #keywords #methodDict).\r\tclassClass at: classClass offsetForKeywords\r\t\tput: #(#name: #superclass: #iv: #keywords: #methodDict:).\r\tclassClass at: classClass offsetForSuperclass put: #ObjObject.\r\tclassClass at: classClass offsetForMethodDict\r\t\tput: (IdentityDictionary new).\r\tObj declareClass: classClass',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ],		#time : DateAndTime [ '2024-12-02T14:46:22.732187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #assembleColoredInstance,			#protocol : #setup,			#sourceCode : 'assembleColoredInstance\r\taColoredPoint := Obj new: 4.\r\taColoredPoint at: 1 put: #ObjColoredPoint.\r\taColoredPoint at: 2 put: 10.\r\taColoredPoint at: 3 put: 15.\r\taColoredPoint at: 4 put: #blue',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ],		#time : DateAndTime [ '2024-12-02T14:46:22.732187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #assembleColoredPointClass,			#protocol : #setup,			#sourceCode : 'assembleColoredPointClass\r\tcoloredPointClass := Obj new: 6.\r\tcoloredPointClass at: pointClass offsetForName put: #ObjColoredPoint.\r\tcoloredPointClass at: pointClass offsetForClass put: #ObjClass.\r\t\r\t"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."\r\tcoloredPointClass at: pointClass offsetForIVs put: #( #class #x #y #color).\r\tcoloredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.\r\tcoloredPointClass at: pointClass offsetForMethodDict\r\t\tput: (IdentityDictionary new).\r\tObj declareClass: coloredPointClass.\r\r\t(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\tTranscript show: \'I\'\'am a colored point\';\r\t\t\t\tcr]] value: pointClass).\r\r\t(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\t(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)\r\t\t\t\t]] value: pointClass).\r\r\t(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\t(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]\r\t\t\t] value: pointClass).',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ],		#time : DateAndTime [ '2024-12-02T14:46:22.733187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #assembleIncrementalColoredInstance,			#protocol : #setup,			#sourceCode : 'assembleIncrementalColoredInstance\r\t\r\taIncrementalColoredPoint := Obj new: 4.\r\taIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.\r\taIncrementalColoredPoint at: 2 put: 10.\r\taIncrementalColoredPoint at: 3 put: 15.\r\taIncrementalColoredPoint at: 4 put: #blue',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ],		#time : DateAndTime [ '2024-12-02T14:46:22.733187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #assembleIncrementalColoredPointClass,			#protocol : #setup,			#sourceCode : 'assembleIncrementalColoredPointClass\r\tincrementalColoredPointClass := Obj new: 6.\r\tincrementalColoredPointClass at: pointClass offsetForName put: #ObjIncrementalColoredPoint.\r\tincrementalColoredPointClass at: pointClass offsetForClass put: #ObjClass.\r\t\r\t"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."\r\tincrementalColoredPointClass at: pointClass offsetForIVs put: #( #color).\r\tincrementalColoredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.\r\tincrementalColoredPointClass at: pointClass offsetForMethodDict\r\t\tput: (IdentityDictionary new).\r\tObj declareClass: incrementalColoredPointClass.\r\r\t(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\tTranscript show: \'I\'\'am a colored point\';\r\t\t\t\tcr]] value: pointClass).\r\r\t(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\t(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)\r\t\t\t\t]] value: pointClass).\r\r\t(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\t(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod)]\r\t\t\t] value: pointClass).',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ],		#time : DateAndTime [ '2024-12-02T14:46:22.734187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #assembleObjectClass,			#protocol : #setup,			#sourceCode : 'assembleObjectClass\r\tobjectClass := Obj new: 6.\r\tobjectClass at: objectClass offsetForName put: #ObjObject.\r\tobjectClass at: objectClass offsetForClass put: #ObjClass.\r\tobjectClass at: objectClass offsetForIVs put: #(#class).\r\tobjectClass at: objectClass offsetForKeywords put: #().\r\tobjectClass at: objectClass offsetForSuperclass put: nil.\r\tobjectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).\r\tObj declareClass: objectClass.\r\r\t"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent\r\tthe superclass of ObjObject"\r\r\t(objectClass at: objectClass offsetForMethodDict) at: #print\r\t\tput: \r\t\t\t([:superClassOfClassDefiningTheMethod |\r\t\t\t\t[:objself | \r\t\t\tTranscript show: \'I\'\'am an Object\';\r\t\t\t\tcr]] value: nil).\r\r\t(objectClass at: objectClass offsetForMethodDict) at: #error\r\t\tput: \r\t\t\t([:superClassOfClassDefiningTheMethod |\r\t\t\t\t[:object :arrayOfArguments | \r\t\t\tTranscript show: \'Error: selector \' , arrayOfArguments first printString , \' not understood\';\r\t\t\t\tcr.\r\t\t\t\tError signal]] value: nil).\r\r\t(objectClass at: objectClass offsetForMethodDict) at: #getIV\r\t\tput: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).\r\r\t(objectClass at: objectClass offsetForMethodDict) at: #setIV\r\t\tput: \r\t\t\t([:superClassOfClassDefiningTheMethod | [:object :iv :val | \r\t\t\tobject at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).\r\r\t(objectClass at: objectClass offsetForMethodDict) at: #bar\r\t\tput: \r\t\t\t([:superClassOfClassDefiningTheMethod | [:objself | \r\t\t\t\t\t5]] value: nil).',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ],		#time : DateAndTime [ '2024-12-02T14:46:22.734187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #assemblePointClass,			#protocol : #setup,			#sourceCode : 'assemblePointClass\r\t| cl |\r\tcl := Obj giveClassNamed: #ObjClass.\r\tpointClass := Obj new: (cl at: cl offsetForIVs) size.\r\tpointClass at: pointClass offsetForName put: #ObjPoint.\r\tpointClass at: pointClass offsetForClass put: #ObjClass.\r\tpointClass at: pointClass offsetForIVs put: #(#class #x #y).\r\tpointClass at: pointClass offsetForKeywords put: #(#x: #y:).\r\tpointClass at: pointClass offsetForSuperclass put: #ObjObject.\r\tpointClass at: pointClass offsetForMethodDict\r\t\tput: (IdentityDictionary new).\r\tObj declareClass: pointClass.\r\r\t(pointClass at: pointClass offsetForMethodDict) at: #x\r\t\tput: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).\r\r\t(pointClass at: pointClass offsetForMethodDict) at: #print\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | [:objself | \r\t\t\tTranscript show: \'I\'\'am a Point\';\r\t\t\t\tcr]] value: objectClass).\r\r\t(pointClass at: pointClass offsetForMethodDict) at: #foo\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\tTranscript show: \'ObjPoint>>foo\';cr.\r\t\t\t\t5\r\t\t\t\t]] value: objectClass)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ],		#time : DateAndTime [ '2024-12-02T14:46:22.734187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #assemblePointInstance,			#protocol : #setup,			#sourceCode : 'assemblePointInstance\r\taPoint := Obj new: 3.\r\taPoint at: 1 put: #ObjPoint.\r\taPoint at: 2 put: 10.\r\taPoint at: 3 put: 15',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ],		#time : DateAndTime [ '2024-12-02T14:46:22.734187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #setup,			#sourceCode : 'setUp\r\t"self new setUp"\r\r\tObj initialize.\r\tself assembleClassClass.\r\tself assemblePointClass.\r\tself assembleObjectClass.\r\tself assembleColoredPointClass.\r\tself assemblePointInstance.\r\tself assembleColoredInstance.\r\tself assembleIncrementalColoredInstance.\r\tself assembleIncrementalColoredPointClass',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ],		#time : DateAndTime [ '2024-12-02T14:46:22.735187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testAllocate,			#protocol : #step5-tests-allocate,			#sourceCode : 'testAllocate\r  "(self  selector: #testAllocate) run"\r  | newInstance |\r  newInstance := pointClass allocateAnInstance.\r  self assert: (newInstance at: 1) = #ObjPoint.\r  self assert: (newInstance size) = 3.\r  self assert: (newInstance at: 2) isNil.\r  self assert: (newInstance at: 3) isNil.\r  self assert: (newInstance objClass = pointClass)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ],		#time : DateAndTime [ '2024-12-02T14:46:22.735187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testBlockArgsFrom,			#protocol : #'utilities tests',			#sourceCode : 'testBlockArgsFrom\r\r\tself assert: (Obj new blockArgsFrom: \' abc def ghi \')  = \':abc :def :ghi\'.\r\tself assert: (Obj new blockArgsFrom: \'abc def ghi\')  = \':abc :def :ghi\'.\r\tself assert: (Obj new blockArgsFrom: \'\')  = \'\'.',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ],		#time : DateAndTime [ '2024-12-02T14:46:22.735187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testBlockBodyFromHeaderAndBody,			#protocol : #'utilities tests',			#sourceCode : 'testBlockBodyFromHeaderAndBody\r\r\t"a method with one argument: val"\r\tself assert: (Obj new stringOfBlockBodyFromHeader: \'val\' andBody: \'objself send: #setIV \r\t\t\t\t\t\t\t\t\t\t withArguments: (Array with: #x with: val).\')\r\t\t\t\t\t\t\t\t\t\t= \'[ :superClassOfClassDefiningTheMethod |\r\t\t[ :objself :val |\r\t\t\t\t\t objself send: #setIV \r\t\t\t\t\t\t\t\t\t\t withArguments: (Array with: #x with: val).] ]\'.\r\r\t"a method without arg"\r\tself assert: (Obj new stringOfBlockBodyFromHeader: \'\' andBody: \'objself unarySend: #getx.\') \r\t=\'[ :superClassOfClassDefiningTheMethod |\r\t\t[ :objself  |\r\t\t\t\t\t objself unarySend: #getx.] ]\'\r\t',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ],		#time : DateAndTime [ '2024-12-02T14:46:22.735187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testClassAccess,			#protocol : #'step3-tests-class access',			#sourceCode : 'testClassAccess\r\t"(self  selector: #testClassAccess) run"\r\t\r\tself assert: (aPoint objClass = pointClass)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ],		#time : DateAndTime [ '2024-12-02T14:46:22.736187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testErrorRaisedSendWhenErrorInLookup,			#protocol : #tests-MessagePassingsAndDynamicsLookup,			#sourceCode : 'testErrorRaisedSendWhenErrorInLookup\r\t"(self  selector: #testErrorRaisedSendWhenErrorInLookup) run"\r\t\r\tself should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.\r\t"Open a Transcript to see the message trace"',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ],		#time : DateAndTime [ '2024-12-02T14:46:22.736187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testErrorRedefinition,			#protocol : #tests,			#sourceCode : 'testErrorRedefinition\r\t"(self  run: #testErrorRedefinition)"\r\t\r\tself should: [aPoint send: #zork withArguments: #()] raise: Error.\r\r\t(pointClass at: pointClass offsetForMethodDict) at: #error\r\t\tput: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).\r\t\r\tself assert: (aPoint send: #zork withArguments: #()) = 33.\r\r\t(pointClass at: pointClass offsetForMethodDict) at: #error\r\t\tput: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).\r\r\tself assert: (aPoint send: #zork withArguments: #(44)) = 33.',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ],		#time : DateAndTime [ '2024-12-02T14:46:22.736187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testIVOffset,			#protocol : #'step4-tests-iv management',			#sourceCode : 'testIVOffset\r\t"(self  selector: #testIVOffset) run"\r\r\tself assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).\r\tself assert: ((pointClass offsetFromClassOfInstanceVariable: #lulu ) = 0)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ],		#time : DateAndTime [ '2024-12-02T14:46:22.736187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testIVOffsetAndValue,			#protocol : #'step4-tests-iv management',			#sourceCode : 'testIVOffsetAndValue\r\t"(self  selector: #testIVOffsetAndValue) run"\r\r\tself assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).\r\tself assert: ((aPoint valueOfInstanceVariable: #x ) = 10)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ],		#time : DateAndTime [ '2024-12-02T14:46:22.737187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testInitialize,			#protocol : #step7-tests-initialize,			#sourceCode : 'testInitialize\r\t"(self  selector: #testInitialize) run"\r\r\t| newInstance  |\r\tnewInstance := pointClass allocateAnInstance.\r\tnewInstance initializeUsing: #(#y: 2 #z: 3 #t: 55 #x: 1).\r\tself assert: (newInstance at: 1) equals: #ObjPoint.\r\tself assert: (newInstance at: 2) equals: 1.\r\tself assert: (newInstance at: 3) equals: 2.',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ],		#time : DateAndTime [ '2024-12-02T14:46:22.737187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testInstanceVariableInheritance,			#protocol : #'step8-tests-instance variable inheritance',			#sourceCode : 'testInstanceVariableInheritance\r\t"(self  selector: #testInstanceVariableInheritance) run"\r\r\t"a better choice would be to throw an exception if there are duplicates"\r\tself assert: \r\t\t\t((Obj new computeNewIVFrom: #(#a #b #c #d) asOrderedCollection\r\t\t\t\twith: #(#a #z #b #t) asOrderedCollection)\r\t\t\t\t\t= #(#a #b #c #d #z #t) asOrderedCollection).\r\tself assert: \r\t\t\t((Obj new computeNewIVFrom: #() asOrderedCollection\r\t\t\t\twith: #(#a #z #b #t) asOrderedCollection)\r\t\t\t\t\t= #(#a #z #b #t) asOrderedCollection)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ],		#time : DateAndTime [ '2024-12-02T14:46:22.737187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testInstanceVariableInheritanceFromAClass,			#protocol : #tests-StaticInheritanceOfInstanceVariables,			#sourceCode : 'testInstanceVariableInheritanceFromAClass\r\r\t"(self  selector: #testInstanceVariableInheritanceFromAClass) run"\r\t\r\taIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).\r\t\r\tself assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).\r\tself assert: ((incrementalColoredPointClass offsetFromClassOfInstanceVariable: #x ) = 2).\r\t\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ],		#time : DateAndTime [ '2024-12-02T14:46:22.738187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testInstanceVariableInheritanceFromAObject,			#protocol : #tests-StaticInheritanceOfInstanceVariables,			#sourceCode : 'testInstanceVariableInheritanceFromAObject\r\r\t"(self  selector: #testInstanceVariableInheritanceFromAObject) run"\r\t\r\taIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).\r\t\r\tself assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).\r\tself assert: ((aIncrementalColoredPoint offsetFromObjectOfInstanceVariable: #x ) = 2).\r\t\r\t\r\t',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ],		#time : DateAndTime [ '2024-12-02T14:46:22.738187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testInstanceVariableInheritanceNotFind,			#protocol : #tests-StaticInheritanceOfInstanceVariables,			#sourceCode : 'testInstanceVariableInheritanceNotFind\r\r\t"(self  selector: #testInstanceVariableInheritanceNotFind) run"\r\t\r\tself should: [aPoint offsetFromObjectOfInstanceVariable: #zork ] raise: Error.\r\t\r\t\r\t',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ],		#time : DateAndTime [ '2024-12-02T14:46:22.738187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testInstanceVariableInheritanceNumberOfInstanceVar,			#protocol : #tests-StaticInheritanceOfInstanceVariables,			#sourceCode : 'testInstanceVariableInheritanceNumberOfInstanceVar\r\r\t"(self  selector: #testInstanceVariableInheritanceNumberOfInstanceVar) run"\r\t\r\tself assert: ((pointClass numberOfIVs ) = 3).\r\tself assert: ((coloredPointClass numberOfIVs ) = 4).\r\t\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ],		#time : DateAndTime [ '2024-12-02T14:46:22.739187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testKeywords,			#protocol : #step6-tests-keywords,			#sourceCode : 'testKeywords\r\t"(self  selector: #testKeywords) run"\r\r\t| dummyObject |\r\tdummyObject := Obj new.\r\tself assert: \r\t\t\t((dummyObject generateKeywords: #(#titi #toto #lulu))\r\t\t\t\t= #(#titi: #toto: #lulu:)).\r\tself assert: \r\t\t\t((dummyObject keywordValue: #x\r\t\t\t\tgetFrom: #(#toto 33 #x 23)\r\t\t\t\tifAbsent: 2) = 23).\r\tself assert: \r\t\t\t((dummyObject keywordValue: #x\r\t\t\t\tgetFrom: #(#toto 23)\r\t\t\t\tifAbsent: 2) = 2).\r\tself assert: \r\t\t\t((dummyObject returnValuesFrom: #(#x 22 #y 35) followingSchema: #(#y #yy #x #y))\r\t\t\t\t= #(35 nil 22 35))',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ],		#time : DateAndTime [ '2024-12-02T14:46:22.739187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodDefinition,			#protocol : #tests,			#sourceCode : 'testMethodDefinition\r\t"(self  selector: #testMethodManagment) run"\r\r\tself assert: (pointClass doesUnderstand: #x).\r\tself assert: (pointClass doesUnderstand: #xx) not.\r\r\t"define a unary method xx returning the receiver."\r\tpointClass \r\t\taddMethod: #xx\r\t\targs: \'\'\r\t\twithBody: \'objself\'.\r\r\tself assert: (pointClass doesUnderstand: #xx).\r\tself assert: (((pointClass bodyOfMethod: #xx) value: 22) = 22).\r\r\t"define a unary method returning the slot x of the receiver"\r\tpointClass \r\t\taddMethod: #getgetx\r\t\targs: \'\'\r\t\twithBody: \'objself valueOfInstanceVariable: #x\'.\r\tself assert: (pointClass doesUnderstand: #getgetx).\r\tself assert: (((pointClass bodyOfMethod: #getgetx) value: aPoint) = 10).',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ],		#time : DateAndTime [ '2024-12-02T14:46:22.739187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodLookup,			#protocol : #tests,			#sourceCode : 'testMethodLookup\r\t"(self  selector: #testMethodLookup) run"\r\t\r\tself assert: ((pointClass lookup: #x) isKindOf: BlockClosure)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ],		#time : DateAndTime [ '2024-12-02T14:46:22.739187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodLookupFindSimpleMethod,			#protocol : #tests-MessagePassingsAndDynamicsLookup,			#sourceCode : 'testMethodLookupFindSimpleMethod\r\t"(self  selector: #testMethodLookupFindSimpleMethod) run"\r\r\tself assert: ((pointClass lookup: #x)  isKindOf: BlockClosure)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ],		#time : DateAndTime [ '2024-12-02T14:46:22.740187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodLookupFindSuperMethod,			#protocol : #tests-MessagePassingsAndDynamicsLookup,			#sourceCode : 'testMethodLookupFindSuperMethod\r\t"(self  selector: #testMethodLookupFindSuperMethod) run"\r\t\r\tself assert: ((coloredPointClass lookup: #x) isKindOf: BlockClosure)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ],		#time : DateAndTime [ '2024-12-02T14:46:22.740187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodLookupStop,			#protocol : #tests-MessagePassingsAndDynamicsLookup,			#sourceCode : 'testMethodLookupStop\r\t"(self  selector: #testMethodLookupStop) run"\r\t\r\t| foundMethod|\r\tfoundMethod := (pointClass lookup: #zork).\r\tself assert: foundMethod isNil. \r\t"The method zork is NOT implement on pointClass, so nil is returned."\r\tself should: [ pointClass sendError: #error withArgs: {aPoint}] raise: Error.\r\t\r\tfoundMethod := (pointClass lookup: #error).\r\tself assert: (foundMethod isKindOf: BlockClosure).\r\tself assert: (\'*Error*\' match: foundMethod printString).\r\t\r\t"the message error defined on ObjObject requires two arguments: an object and a selector and it raises \r\tan error when executed. Open a Transcript to see the message trace"\r\tself should:  [((pointClass lookup: #zork) value: \'r\' value: #e)] raise: Error .',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ],		#time : DateAndTime [ '2024-12-02T14:46:22.740187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodManagement,			#protocol : #tests,			#sourceCode : 'testMethodManagement\r\t"(self  selector: #testMethodManagment) run"\r\r\tself assert: (pointClass doesUnderstand: #x).\r\tself assert: (pointClass doesUnderstand: #xx) not.\r\t\r\tpointClass \r\t\taddMethod: #xx\r\t\targs: \'\'\r\t\twithBody: \'objself valueOfInstanceVariable: #x \'.\r\tself assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).\r\tself assert: (pointClass doesUnderstand: #xx).\r\tpointClass removeMethod: #xx.\r\tself assert: (pointClass doesUnderstand: #xx) not.\r\tself assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ],		#time : DateAndTime [ '2024-12-02T14:46:22.741187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodManagmentAddRemoveMethods,			#protocol : #tests-MethodsManagement,			#sourceCode : 'testMethodManagmentAddRemoveMethods\r\t"(self  selector: #testMethodManagmentAddRemoveMethods) run"\r\r\tpointClass \r\t\taddMethod: #xx\r\t\targs: \'\'\r\t\twithBody: \'objself valueOfInstanceVariable: #x \'.\r\tself assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).\r\tself assert: (pointClass doesUnderstand: #xx).\r\tpointClass removeMethod: #xx.\r\tself assert: (pointClass doesUnderstand: #xx) not.\r\tself assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ],		#time : DateAndTime [ '2024-12-02T14:46:22.741187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodManagmentBodyOfMethod,			#protocol : #tests-MethodsManagement,			#sourceCode : 'testMethodManagmentBodyOfMethod\r\t"(self  selector: #testMethodManagmentBodyOfMethod) run"\r\t\r\tself assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ],		#time : DateAndTime [ '2024-12-02T14:46:22.741187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodManagmentNotUnderstandBadMethod,			#protocol : #tests-MethodsManagement,			#sourceCode : 'testMethodManagmentNotUnderstandBadMethod\r\t"(self  selector: #testMethodManagmentNotUnderstandBadMethod) run"\r\r\tself assert: (pointClass doesUnderstand: #xx) not.\r\t',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ],		#time : DateAndTime [ '2024-12-02T14:46:22.741187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodManagmentUnderstandGoodMethod,			#protocol : #tests-MethodsManagement,			#sourceCode : 'testMethodManagmentUnderstandGoodMethod\r\t"(self  selector: #testMethodManagmentUnderstandGoodMethod) run"\r\r\tself assert: (pointClass doesUnderstand: #x).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ],		#time : DateAndTime [ '2024-12-02T14:46:22.742187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodNotFoundRaiseError,			#protocol : #tests,			#sourceCode : 'testMethodNotFoundRaiseError\r\t"(self  run: #testMethodNotFoundRaiseError)"\r\r\tself should: [aPoint send: #zork withArguments: #()] raise: Error.',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ],		#time : DateAndTime [ '2024-12-02T14:46:22.742187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodSelfSend,			#protocol : #tests,			#sourceCode : 'testMethodSelfSend\r\t"(self  selector: #testMethodSelfSend) run"\r\r\t"method found in the class PointClass"\r\tself assert: ((aPoint send: #x withArguments: #()) = 10).\r\r\t"method found in ObjClass"\r\tself assert: ((aPoint send: #getIV withArguments: #(#x)) = 10).\r\r\t"method found in ObjClass"\r\taPoint send: #setIV withArguments: #(y 22).\r\tself assert: ((aPoint send: #getIV withArguments: #(#y)) = 22)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ],		#time : DateAndTime [ '2024-12-02T14:46:22.746187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodSelfSendUnarySend,			#protocol : #tests-MessagePassingsAndDynamicsLookup,			#sourceCode : 'testMethodSelfSendUnarySend\r\t"(self  selector: #testMethodSelfSendUnarySend) run"\r\r\t"method found in the class PointClass"\r\tself assert: ((aPoint send: #x withArguments: #()) = 10).\r\t"method found in the class PointClass"\r\tself assert: ((aColoredPoint send: #x withArguments:#()) = 10).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ],		#time : DateAndTime [ '2024-12-02T14:46:22.746187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodSuperCall,			#protocol : #tests,			#sourceCode : 'testMethodSuperCall\r\t"(self  selector: #testMethodSuperCall) run"\r\r\t"foo in point return 5"\r\tself assert: ((aPoint send: #foo withArguments: #()) = 5).\r\r\t"foo in colored point is doing super foo + super foo"\r\tself assert: ((aColoredPoint send: #foo withArguments: #()) = 10).',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ],		#time : DateAndTime [ '2024-12-02T14:46:22.746187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodSuperCallOverBigHierarchy,			#protocol : #tests,			#sourceCode : 'testMethodSuperCallOverBigHierarchy\r\t"(self  selector: #testMethodSuperCallOverBigHierarchy) run"\r\r\t"bar is defined in Object and not on Point"\r\tself assert: (aPoint send: #bar withArguments: #()) = 5.\r\r\t"bar on coloredPoint = super bar + super bar"\r\tself assert: (aColoredPoint send: #bar withArguments: #()) = 10.',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ],		#time : DateAndTime [ '2024-12-02T14:46:22.747187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testMethodWithHeaderAndBody,			#protocol : #'utilities tests',			#sourceCode : 'testMethodWithHeaderAndBody\r\r\t"a method simply returning objself"\r\tself assert: ((pointClass\r\t\t\t\t\tmethodWithHeader: \'\'\r\t\t\t\t\tandBody: \'objself \') value: 2) = 2.\r\t\r\t"a method returning its first none implicit arg"\r\tself assert: ((pointClass \r\t\t\t\t\tmethodWithHeader: \'val\'\r\t\t\t\t\tandBody: \'val \') value: 2 value: 33) = 33.\r\r\t"a method returns its superclass of the class defining the method value"\r\t"this anonymous method is defined in pointClass so its superclass pointer is objectClass"\r\tself assert: ((pointClass \r\t\t\t\t\tmethodWithHeader: \'\'\r\t\t\t\t\tandBody: \' superClassOfClassDefiningTheMethod \') value: aPoint) = objectClass .\r\r\tself assert: ((coloredPointClass \r\t\t\t\t\tmethodWithHeader: \'\'\r\t\t\t\t\tandBody: \' superClassOfClassDefiningTheMethod \') value: aPoint) = pointClass .',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ],		#time : DateAndTime [ '2024-12-02T14:46:22.747187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testNilWhenErrorInLookup,			#protocol : #tests-MessagePassingsAndDynamicsLookup,			#sourceCode : 'testNilWhenErrorInLookup\r\t"(self  selector: #testNilWhenErrorInLookup) run"\r\t\r\tself assert: (pointClass lookup: #zork) isNil.\r\t"The method zork is NOT implement on pointClass"\r\t',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ],		#time : DateAndTime [ '2024-12-02T14:46:22.747187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructure,			#protocol : #tests,			#sourceCode : 'testPrimitiveStructure\r\t"(self selector: #testPrimitiveStructure) run"\r\t\r\tself assert: (pointClass objClassId = #ObjClass).\r\tself assert: ((pointClass objName ) = #ObjPoint).\r\tself assert: ((pointClass objSuperclassId ) = #ObjObject).\r\tself assert: ((pointClass objIVs) = #(#class #x #y)).\r\tself assert: ((pointClass objKeywords) = #(#x: #y:)).\r\tself assert: ((pointClass objMethodDict) = nil) not',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ],		#time : DateAndTime [ '2024-12-02T14:46:22.748187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjClassId,			#protocol : #'step1-tests-structure of objects',			#sourceCode : 'testPrimitiveStructureObjClassId\r\t"(self selector: #testPrimitiveStructureObjClassId) run"\r\r\tself assert: (pointClass objClassId = #ObjClass).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ],		#time : DateAndTime [ '2024-12-02T14:46:22.748187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjClassIdForSimpleObject,			#protocol : #'step1-tests-structure of objects',			#sourceCode : 'testPrimitiveStructureObjClassIdForSimpleObject\r\t"self run: #testPrimitiveStructureObjClassIdForSimpleObject"\r\r\tself assert: (aPoint objClassId = #ObjPoint).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ],		#time : DateAndTime [ '2024-12-02T14:46:22.748187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjIVs,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjIVs\r\t"(self selector: #testPrimitiveStructureObjIVs) run"\r\r\tself assert: ((pointClass objIVs) = #(#class #x #y)).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ],		#time : DateAndTime [ '2024-12-02T14:46:22.748187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjKeywords,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjKeywords\r\t"(self selector: #testPrimitiveStructureObjKeywords) run"\r\r\tself assert: ((pointClass objKeywords) = #(#x: #y:)).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ],		#time : DateAndTime [ '2024-12-02T14:46:22.749187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjMethodDict,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjMethodDict\r\t"(self selector: #testPrimitiveStructureObjMethodDict) run"\r\r\tself assert: ((pointClass objMethodDict) = nil) not',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ],		#time : DateAndTime [ '2024-12-02T14:46:22.749187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjName,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjName\r\t"(self selector: #testPrimitiveStructureObjName) run"\r\r\tself assert: ((pointClass objName ) = #ObjPoint).\r\t',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ],		#time : DateAndTime [ '2024-12-02T14:46:22.749187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjSuperclassId,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjSuperclassId\r\t"(self selector: #testPrimitiveStructureObjSuperclassId) run"\r\r\tself assert: ((pointClass objSuperclassId ) = #ObjObject).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ],		#time : DateAndTime [ '2024-12-02T14:46:22.749187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testRaisesErrorSendWhenErrorInLookup,			#protocol : #tests-MessagePassingsAndDynamicsLookup,			#sourceCode : 'testRaisesErrorSendWhenErrorInLookup\r\t"(self  selector: #testRaisesErrorSendWhenErrorInLookup) run"\r\r\tself should: [ pointClass send: #zork withArguments: { aPoint } ] raise: Error.\r\t"Open a Transcript to see the message trace"',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ],		#time : DateAndTime [ '2024-12-02T14:46:22.750187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #testSendErrorRaisesErrorSendWhenErrorInLookup,			#protocol : #tests-MessagePassingsAndDynamicsLookup,			#sourceCode : 'testSendErrorRaisesErrorSendWhenErrorInLookup\r\t"(self  selector: #testSendErrorRaisesErrorSendWhenErrorInLookup) run"\r\t\r\tself should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.\r\t"Open a Transcript to see the message trace"',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ],		#time : DateAndTime [ '2024-12-02T14:46:22.750187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTestBootstrap,				#isMetaSide : false			},			#name : #testCreateObjClassMessage,			#protocol : #'test ObjClass creation',			#sourceCode : 'testCreateObjClassMessage\r\t"(self selector: #testCreateObjClassMessage) run"\r\r\t| objClass |\r\tObj bootstrap.\r\tobjClass := Obj giveClassNamed: #ObjClass.\r\tself assert: ((objClass send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass)).\r\tself assert: (objClass send: #isClass withArguments: #()).\r\tself assert: (objClass send: #isMetaclass withArguments: #())',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ],		#time : DateAndTime [ '2024-12-02T14:46:22.750187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTestBootstrap,				#isMetaSide : false			},			#name : #testCreateObjClassStructure,			#protocol : #'test ObjClass creation',			#sourceCode : 'testCreateObjClassStructure\r\t"(self selector: #testCreateObjClassStructure) run"\r\r\t| objClass |\r\tObj bootstrap.\r\tobjClass := Obj giveClassNamed: #ObjClass.\r\tself assert: (objClass objName = #ObjClass).\r\tself assert: (objClass objClassId = #ObjClass).\r\tself assert: (objClass objSuperclassId = #ObjObject).\r\tself assert: (objClass objIVs asArray = #(#class #name #superclass #iv #keywords #methodDict)).\r\tself assert: (objClass objKeywords asArray = #(#name: #superclass: #iv: #keywords: #methodDict:))',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ],		#time : DateAndTime [ '2024-12-02T14:46:22.751187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTestBootstrap,				#isMetaSide : false			},			#name : #testCreateObjObjectInstanceMessage,			#protocol : #'test ObjObject creation ',			#sourceCode : 'testCreateObjObjectInstanceMessage\r\t"(self selector: #testCreateObjObjectInstanceMessage) run"\r\r\t| pointClass objClass pointInstance |\r\tObj initialize.\r\tObj manuallyCreateObjClass.\r\tObj createObjObject.\r\tobjClass := Obj giveClassNamed: #ObjClass.\r\tpointClass := objClass \r\t\t\t\t\t\t\tsend: #new\r\t\t\t\t\t\t\twithArguments: #(#(#name: #ObjPoint #superclass: #ObjObject #iv: #(#x #y))).\r\tpointInstance := pointClass send: #new withArguments: #(#()).\r\tself assert: (pointInstance objClassId = #ObjPoint).\r\tself assert: ((pointInstance send: #getIV withArguments: #(#x)) = nil).\r\tpointInstance send: #setIV withArguments: #(#x 25).\r\tself assert:  ((pointInstance send: #getIV withArguments: #(x)) = 25 )',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ],		#time : DateAndTime [ '2024-12-02T14:46:22.751187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTestBootstrap,				#isMetaSide : false			},			#name : #testCreateObjObjectMessage,			#protocol : #'test ObjObject creation ',			#sourceCode : 'testCreateObjObjectMessage\r\t"(self selector: #testCreateObjObjectMessage) run"\r\r\t| objObject |\r\tObj initialize.\r\tObj manuallyCreateObjClass.\r\tObj createObjObject.\r\tobjObject := Obj giveClassNamed: #ObjObject.\r\tself assert: (objObject send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass).\r\tself assert: (objObject send: #isClass withArguments: #()) not.\r\tself assert: (objObject send: #getIV withArguments: #(#class)) = #ObjClass',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ],		#time : DateAndTime [ '2024-12-02T14:46:22.751187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTestBootstrap,				#isMetaSide : false			},			#name : #testCreateObjObjectStructure,			#protocol : #'test ObjObject creation ',			#sourceCode : 'testCreateObjObjectStructure\r\t"(self selector: #testCreateObjObjectStructure) run"\r\r\t| objObject |\r\tObj initialize.\r\tObj manuallyCreateObjClass.\r\tObj createObjObject.\r\tobjObject := Obj giveClassNamed: #ObjObject.\r\tself assert: (objObject objName = #ObjObject).\r\tself assert: (objObject objClassId = #ObjClass).\r\tself assert: (objObject objSuperclassId isNil).\r\tself assert: (objObject objIVs asArray = #(#class)).\r\tself assert: (objObject objKeywords asArray = #())',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ],		#time : DateAndTime [ '2024-12-02T14:46:22.751187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTestBootstrap,				#isMetaSide : false			},			#name : #testManuallyCreateObjClassAllocate,			#protocol : #'test ObjClass manual creation ',			#sourceCode : 'testManuallyCreateObjClassAllocate\r\t"(self selector: #testManuallyCreateObjClassAllocate) run"\r\r\t| objClass emptyClass |\r\tObj initialize.\r\tObj manuallyCreateObjClass.\r\tobjClass := Obj giveClassNamed: #ObjClass.\r\temptyClass := objClass send: #allocate withArguments: #().\r\tself assert: emptyClass objClassId = #ObjClass.\r\tself assert:  emptyClass objSuperclassId isNil.\r\tself assert:  emptyClass objIVs isNil.\r\tself assert:  emptyClass objKeywords isNil.\r\tself assert:  emptyClass objMethodDict isNil.\r\tself assert:  emptyClass objName isNil',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ],		#time : DateAndTime [ '2024-12-02T14:46:22.752187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTestBootstrap,				#isMetaSide : false			},			#name : #testManuallyCreateObjClassStructure,			#protocol : #'test ObjClass manual creation ',			#sourceCode : 'testManuallyCreateObjClassStructure\r\t"(self selector: #testManuallyCreateObjClassStructure) run"\r\r\t| objClass |\r\tObj initialize.\r\tObj manuallyCreateObjClass.\r\tobjClass := Obj giveClassNamed: #ObjClass.\r\tself assert: (objClass objName = #ObjClass).\r\tself assert: (objClass objClassId = #ObjClass).\r\tself assert: (objClass objClass == objClass).\r\tself assert: (objClass objSuperclassId = #ObjObject).\t\r\t"the fact that the created first class inherits form ObjObject is not necessary\r\tbecause there is no super calls"\r\tself assert: (objClass objIVs = #(#class #name #superclass #iv #keywords #methodDict)).\r\tself assert: (objClass objKeywords = #(#name: #superclass: #iv: #keywords: #methodDict:))',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ],		#time : DateAndTime [ '2024-12-02T14:46:22.752187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #assembleClassClass,			#protocol : #setup,			#sourceCode : 'assembleClassClass\r\tclassClass := Obj new: 6.\r\tclassClass at: 2 put: #ObjClass.\r\tclassClass at: 1 put: #ObjClass.\r\tclassClass at: 4 put: #(#class #name #superclass #iv #keywords #methodDict).\r\tclassClass at: 5 put: #(#name: #superclass: #iv: #keywords: #methodDict:).\r\tclassClass at: 3 put: #ObjObject.\r\tclassClass at: 6 put: (IdentityDictionary new).\r\tObj declareClass: classClass',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ],		#time : DateAndTime [ '2024-12-02T14:46:22.752187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #assembleColoredInstance,			#protocol : #setup,			#sourceCode : 'assembleColoredInstance\r\taColoredPoint := Obj new: 4.\r\taColoredPoint at: 1 put: #ObjColoredPoint.\r\taColoredPoint at: 2 put: 10.\r\taColoredPoint at: 3 put: 15.\r\taColoredPoint at: 4 put: #blue',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ],		#time : DateAndTime [ '2024-12-02T14:46:22.753187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #assembleColoredPointClass,			#protocol : #setup,			#sourceCode : 'assembleColoredPointClass\r\tcoloredPointClass := Obj new: 6.\r\tcoloredPointClass at: 2 put: #ObjColoredPoint.\r\tcoloredPointClass at: 1 put: #ObjClass.\r\t"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."\r\tcoloredPointClass at: 4 put: #( #class #x #y #color).\r\tcoloredPointClass at: 3 put: #ObjPoint.\r\tcoloredPointClass at: 6 put: (IdentityDictionary new).\r\tObj declareClass: coloredPointClass.\r\r\t(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\tTranscript show: \'I\'\'am a colored point\';\r\t\t\t\tcr]] value: pointClass).\r\r\t(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\t(objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod)\r\t\t\t\t]] value: pointClass).\r\r\t(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\t(objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]\r\t\t\t] value: pointClass).',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ],		#time : DateAndTime [ '2024-12-02T14:46:22.753187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #assembleIncrementalColoredInstance,			#protocol : #setup,			#sourceCode : 'assembleIncrementalColoredInstance\r\t\r\taIncrementalColoredPoint := Obj new: 4.\r\taIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.\r\taIncrementalColoredPoint at: 2 put: 10.\r\taIncrementalColoredPoint at: 3 put: 15.\r\taIncrementalColoredPoint at: 4 put: #blue',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ],		#time : DateAndTime [ '2024-12-02T14:46:22.753187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #assembleIncrementalColoredPointClass,			#protocol : #setup,			#sourceCode : 'assembleIncrementalColoredPointClass\r\tincrementalColoredPointClass := Obj new: 6.\r\tincrementalColoredPointClass at: 2 put: #ObjIncrementalColoredPoint.\r\tincrementalColoredPointClass at: 1 put: #ObjClass.\r\t"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."\r\tincrementalColoredPointClass at: 4 put: #( #color).\r\tincrementalColoredPointClass at: 3 put: #ObjPoint.\r\tincrementalColoredPointClass at: 6 put: (IdentityDictionary new).\r\tObj declareClass: incrementalColoredPointClass.\r\r\t(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\tTranscript show: \'I\'\'am a colored point\';\r\t\t\t\tcr]] value: pointClass).\r\r\t(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\t(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)\r\t\t\t\t]] value: pointClass).\r\r\t(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\t(objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod)]\r\t\t\t] value: pointClass).',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ],		#time : DateAndTime [ '2024-12-02T14:46:22.754187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #assembleObjectClass,			#protocol : #setup,			#sourceCode : 'assembleObjectClass\r\tobjectClass := Obj new: 6.\r\tobjectClass at: 2 put: #ObjObject.\r\tobjectClass at: 1 put: #ObjClass.\r\tobjectClass at: objectClass offsetForIVs put: #(#class).\r\tobjectClass at: objectClass offsetForKeywords put: #().\r\tobjectClass at: objectClass offsetForSuperclass put: nil.\r\tobjectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).\r\tObj declareClass: objectClass.\r\r\t"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent\r\tthe superclass of ObjObject"\r\r\t(objectClass at: objectClass offsetForMethodDict) at: #print\r\t\tput: \r\t\t\t([:superClassOfClassDefiningTheMethod |\r\t\t\t\t[:objself | \r\t\t\tTranscript show: \'I\'\'am an Object\';\r\t\t\t\tcr]] value: nil).\r\r\t(objectClass at: objectClass offsetForMethodDict) at: #error\r\t\tput: \r\t\t\t([:superClassOfClassDefiningTheMethod |\r\t\t\t\t[:object :selector | \r\t\t\tTranscript show: \'Error: selector \' , selector printString , \' not understood\';\r\t\t\t\tcr.\r\t\t\t\tError signal]] value: nil).\r\r\t(objectClass at: objectClass offsetForMethodDict) at: #getIV\r\t\tput: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).\r\r\t(objectClass at: objectClass offsetForMethodDict) at: #setIV\r\t\tput: \r\t\t\t([:superClassOfClassDefiningTheMethod | [:object :iv :val | \r\t\t\tobject at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).\r\r\t(objectClass at: objectClass offsetForMethodDict) at: #bar\r\t\tput: \r\t\t\t([:superClassOfClassDefiningTheMethod | [:objself | \r\t\t\t\t\t5]] value: nil).',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ],		#time : DateAndTime [ '2024-12-02T14:46:22.754187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #assemblePointClass,			#protocol : #setup,			#sourceCode : 'assemblePointClass\r\t| cl |\r\tcl := Obj giveClassNamed: #ObjClass.\r\tpointClass := Obj new: (cl at: cl offsetForIVs) size.\r\tpointClass at: 2 put: #ObjPoint.\r\tpointClass at: 1 put: #ObjClass.\r\tpointClass at: 4 put: #(#class #x #y).\r\tpointClass at: 5 put: #(#x: #y:).\r\tpointClass at: 3 put: #ObjObject.\r\tpointClass at: 6 put: (IdentityDictionary new).\r\tObj declareClass: pointClass.\r\r\t(pointClass at: pointClass offsetForMethodDict) at: #x\r\t\tput: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).\r\r\t(pointClass at: pointClass offsetForMethodDict) at: #print\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | [:objself | \r\t\t\tTranscript show: \'I\'\'am a Point\';\r\t\t\t\tcr]] value: objectClass).\r\r\t(pointClass at: pointClass offsetForMethodDict) at: #foo\r\t\tput: \r\t\t\t([ :superClassOfClassDefiningTheMethod | \r\t\t\t\t[:objself | \r\t\t\t\tTranscript show: \'ObjPoint>>foo\';cr.\r\t\t\t\t5\r\t\t\t\t]] value: objectClass)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ],		#time : DateAndTime [ '2024-12-02T14:46:22.754187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #assemblePointInstance,			#protocol : #setup,			#sourceCode : 'assemblePointInstance\r\taPoint := Obj new: 3.\r\taPoint at: 1 put: #ObjPoint.\r\taPoint at: 2 put: 10.\r\taPoint at: 3 put: 15',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ],		#time : DateAndTime [ '2024-12-02T14:46:22.754187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #setup,			#sourceCode : 'setUp\r\t"self new setUp"\r\r\tObj initialize.\r\tself assembleClassClass.\r\tself assemblePointClass.\r\tself assembleObjectClass.\r\tself assembleColoredPointClass.\r\tself assemblePointInstance.\r\tself assembleColoredInstance.\r\tself assembleIncrementalColoredInstance.\r\tself assembleIncrementalColoredPointClass',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ],		#time : DateAndTime [ '2024-12-02T14:46:22.755187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testClassAccess,			#protocol : #'step3-tests-class access',			#sourceCode : 'testClassAccess\r\t"(self  selector: #testClassAccess) run"\r\t\r\tself assert: (aPoint objClass = pointClass)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ],		#time : DateAndTime [ '2024-12-02T14:46:22.755187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjClassId,			#protocol : #'step1-tests-structure of objects',			#sourceCode : 'testPrimitiveStructureObjClassId\r\t"(self selector: #testPrimitiveStructureObjClassId) run"\r\r\tself assert: (pointClass objClassId = #ObjClass).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ],		#time : DateAndTime [ '2024-12-02T14:46:22.755187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjClassIdForSimpleObject,			#protocol : #'step1-tests-structure of objects',			#sourceCode : 'testPrimitiveStructureObjClassIdForSimpleObject\r\t"self run: #testPrimitiveStructureObjClassIdForSimpleObject"\r\r\tself assert: (aPoint objClassId = #ObjPoint).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ],		#time : DateAndTime [ '2024-12-02T14:46:22.755187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjIVs,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjIVs\r\t"(self selector: #testPrimitiveStructureObjIVs) run"\r\r\tself assert: ((pointClass objIVs) = #(#class #x #y)).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ],		#time : DateAndTime [ '2024-12-02T14:46:22.755187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjKeywords,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjKeywords\r\t"(self selector: #testPrimitiveStructureObjKeywords) run"\r\r\tself assert: ((pointClass objKeywords) = #(#x: #y:)).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ],		#time : DateAndTime [ '2024-12-02T14:46:22.756187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjMethodDict,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjMethodDict\r\t"(self selector: #testPrimitiveStructureObjMethodDict) run"\r\r\tself assert: ((pointClass objMethodDict) = nil) not',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ],		#time : DateAndTime [ '2024-12-02T14:46:22.756187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjName,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjName\r\t"(self selector: #testPrimitiveStructureObjName) run"\r\r\tself assert: ((pointClass objName ) = #ObjPoint).\r\t',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ],		#time : DateAndTime [ '2024-12-02T14:46:22.756187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjSuperclassId,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjSuperclassId\r\t"(self selector: #testPrimitiveStructureObjSuperclassId) run"\r\r\tself assert: ((pointClass objSuperclassId ) = #ObjObject).\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ],		#time : DateAndTime [ '2024-12-02T14:46:22.756187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #addMessagesForErrorHandling,			#protocol : #'bootstrap objMessage',			#sourceCode : 'addMessagesForErrorHandling\r\t"pre condition message has been created (and declared)"\r\t"self addMessagesForErrorHandling"\r\t| objMessage |\r\tobjMessage := self ObjMessage.\r\r\tobjMessage \r\t\taddUnaryMethod: #receiver \r\t\twithBody: \'objself valueOfInstanceVariable: #receiver\'.\r\r\tobjMessage \r\t\taddUnaryMethod: #receiver2 \r\t\twithBody: \'objself send: #getIV withArguments: #(#receiver)\'.\r\r\tobjMessage \r\t\taddUnaryMethod: #selector \r\t\twithBody: \'objself send: #getIV withArguments: #(#selector)\'.\r\t\t\r\tobjMessage \r\t\taddUnaryMethod: #arguments \r\t\twithBody: \'objself send: #getIV withArguments: #(#arguments)\'.\r\t\r\tobjMessage \r\t\taddMethod: #setReceiver\r\t\targs: \'receiver\'\r\t\twithBody:\' objself send: #setIV withArguments: (Array with: #receiver with: receiver)\'.\r\t\t\r\tobjMessage \r\t\taddMethod: #setSelector\r\t\targs: \'selector\'\r\t\twithBody:\' objself send: #setIV withArguments: (Array with: #selector with: selector)\'.\r\r\tobjMessage \r\t\taddMethod: #setArguments\r\t\targs: \'arguments\'\r\t\twithBody:\' objself send: #setIV withArguments: (Array with: #arguments with: arguments)\'.\t\t\r\t\t\t\t\r\t^ objMessage ',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ],		#time : DateAndTime [ '2024-12-02T14:46:22.757187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #bootstrap,			#protocol : #'bootstrap objClass manually',			#sourceCode : 'bootstrap\r\t"self bootstrap"\r\t\r\tself initialize.\r\tself manuallyCreateObjClass.\r\tself createObjObject.\r\tself createObjClass.',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ],		#time : DateAndTime [ '2024-12-02T14:46:22.757187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #classInstanceVariables,			#protocol : #'meta data',			#sourceCode : 'classInstanceVariables\r\t^ #(#class #name #superclass #iv #keywords #methodDict)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ],		#time : DateAndTime [ '2024-12-02T14:46:22.757187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #createObjClass,			#protocol : #'bootstrap objClass',			#sourceCode : 'createObjClass\r\t"self bootstrap"\r\r\t| objClass |\r\tobjClass := self objClassStructure.\r\tself defineAllocateMethodIn: objClass.\r\tself defineNewMethodIn: objClass.\r\tself defineInitializeMethodIn: objClass.\r\tobjClass \r\t\taddUnaryMethod: #isMetaclass\r\t\twithBody: \'objself objIVs includes: #superclass\'.\t\r\t"an object is a class if is class is a metaclass. cool"\r\t\r\tobjClass \r\t\taddUnaryMethod: #isClass\r\t\twithBody: \'objself objClass send: #isMetaclass withArguments:#()\'.\r\r\t^objClass',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ],		#time : DateAndTime [ '2024-12-02T14:46:22.757187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #createObjObject,			#protocol : #'bootstrap objObject',			#sourceCode : 'createObjObject\r\t| objObject |\r\tobjObject := self objObjectStructure.\r\tobjObject addUnaryMethod: #class withBody: \'objself objClass\'.\r\tobjObject addUnaryMethod: #isClass withBody: \'false\'.\r\tobjObject addUnaryMethod: #isMetaclass withBody: \'false\'. \r\tobjObject \r\t\taddMethod: #error\r\t\targs: \'arrayOfArguments\'\r\t\twithBody: \'Transcript show: \'\'error \'\', arrayOfArguments first.  \'\'error \'\', arrayOfArguments first\'.\r\r\t"some meta facilities"\r\tobjObject \r\t\taddMethod: #getIV\r\t\targs: \'iv\'\r\t\twithBody: \'objself valueOfInstanceVariable: iv\'.\r\r\tobjObject \r\t\taddMethod: #setIV\r\t\targs: \'iv val\'\r\t\twithBody: \r\t\t\t\' objself at: (objself offsetFromObjectOfInstanceVariable: iv) put: val\'.\r\r\tobjObject \r\t\taddMethod: #initialize\r\t\targs: \'initargs\'\r\t\twithBody: \'objself  initializeUsing: initargs\'.\r\t^objObject',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ],		#time : DateAndTime [ '2024-12-02T14:46:22.758187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'declareClass:',			#protocol : #'global class repository management',			#sourceCode : 'declareClass: anObjClass \r\t"To declare an ObjClass in the class repository"\r\r\t| nameC |\r\tnameC := anObjClass objName.\r\tnameC isNil\r\t\tifFalse: [definedObjClasses at: nameC put: anObjClass]\r\t\tifTrue: [self error: \'The class does not have a name\']',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ],		#time : DateAndTime [ '2024-12-02T14:46:22.758187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineAllocateMethodIn:',			#protocol : #'bootstrap objClass manually',			#sourceCode : 'defineAllocateMethodIn: class \r\t"The allocated obj method simply invokes the primitive allocateAnInstance."\r\t\r\tclass \r\t\taddUnaryMethod: #allocate \r\t\twithBody: \'objself allocateAnInstance\'',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ],		#time : DateAndTime [ '2024-12-02T14:46:22.758187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineInitializeMethodIn:',			#protocol : #'bootstrap objClass',			#sourceCode : 'defineInitializeMethodIn: objClass \r\r\tobjClass \r\t\taddMethod: #initialize\r\t\targs: \'initArray\'\r\t\twithBody: \r\t\t\t\'objself super: #initialize withArguments: {initArray} from: superClassOfClassDefiningTheMethod.\r\t\t\tobjself objIVs: (objself\r\t\t\t\t\t\t\tcomputeNewIVFrom: (Obj giveClassNamed: objself objSuperclassId) objIVs\r\t\t\t\t\t\t\twith: objself objIVs).\r\t\t\tobjself computeAndSetKeywords.\r\t\t\tobjself objMethodDict: IdentityDictionary new.\r\t\t\tObj declareClass: objself.\r\t\t\tobjself\'',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ],		#time : DateAndTime [ '2024-12-02T14:46:22.758187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineManualInitializeMethodIn:',			#protocol : #'bootstrap objClass manually',			#sourceCode : 'defineManualInitializeMethodIn: class \r\r\tclass \r\t\taddMethod: #initialize\r\t\targs: \'initArray\'\r\t\twithBody: \t\r\t\t\t\'| objsuperclass |\r\t\t\tobjself initializeUsing: initArray.\t"Initialize a class as an object. In the bootstrapped system will be done via super"\r\t\t\tobjsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].\r\t\t\tobjsuperclass isNil\r\t\t\t\tifFalse: \r\t\t\t\t\t[objself\r\t\t\t\t\t\tobjIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]\r\t\t\t\tifTrue: \r\t\t\t\t\t[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].\r\t\t\tobjself\r\t\t\t\tobjKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).\r\t\t\tobjself objMethodDict: (IdentityDictionary new: 3).\r\t\t\tObj declareClass: objself.\r\t\t\tobjself\'',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ],		#time : DateAndTime [ '2024-12-02T14:46:22.758187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineNewMethodIn:',			#protocol : #'bootstrap objClass manually',			#sourceCode : 'defineNewMethodIn: class \r\r\tclass \r\t\taddMethod: #new\r\t\targs: \'initArray\'\r\t\twithBody: \r\t\t\t\'(objself send: #allocate withArguments: #()) send: #initialize withArguments: { initArray } \'.',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ],		#time : DateAndTime [ '2024-12-02T14:46:22.759187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'doesNotUnderstand:',			#protocol : #tricks,			#sourceCode : 'doesNotUnderstand: aMessage\r\r\t"debugging >>>  default shiftDown ifTrue:[ self halt ]."\r\t"Sensor shiftPressed ifTrue:[ self halt ]."\r\t\r\t^ definedObjClasses at: aMessage selector',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ],		#time : DateAndTime [ '2024-12-02T14:46:22.759187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'giveClassNamed:',			#protocol : #'global class repository management',			#sourceCode : 'giveClassNamed: aSymbol \r\t"Return the class defined in the class repository with the name aSymbol"\r\r\t^ self giveClassNamed: aSymbol ifAbsent: [self error: (\'The class \' , aSymbol printString , \' is not defined\')]',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ],		#time : DateAndTime [ '2024-12-02T14:46:22.759187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'giveClassNamed:ifAbsent:',			#protocol : #'global class repository management',			#sourceCode : 'giveClassNamed: aSymbol ifAbsent: aBlock\r\r\t^ definedObjClasses at: aSymbol ifAbsent: aBlock',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ],		#time : DateAndTime [ '2024-12-02T14:46:22.759187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"self initialize"\t\r \r\tdefinedObjClasses := IdentityDictionary new.\r\tdefinedObjClasses at: #ObjClass put: nil.\r\tdefinedObjClasses at: #ObjObject put: nil.\r\tdefinedObjClasses at: #ObjMessage put: nil.',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ],		#time : DateAndTime [ '2024-12-02T14:46:22.759187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #manualObjClassStructure,			#protocol : #'bootstrap objClass manually',			#sourceCode : 'manualObjClassStructure\r\t| class |\r\tclass := Obj new: 6.\r\tclass objClassId: #ObjClass.\r\tclass objName: #ObjClass.\r\tclass objIVs: self classInstanceVariables.\r\tclass objKeywords: #(#name: #superclass: #iv: #keywords: #methodDict:).\r\tclass objSuperclassId: #ObjObject.\r\tclass objMethodDict: (IdentityDictionary new: 3).\r\t^ class',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ],		#time : DateAndTime [ '2024-12-02T14:46:22.760187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #manuallyCreateObjClass,			#protocol : #'bootstrap objClass manually',			#sourceCode : 'manuallyCreateObjClass\r\t"self manuallyCreateObjClass"\r\r\t| class |\r\tclass := self manualObjClassStructure.\r\tObj declareClass: class.\r\tself defineManualInitializeMethodIn: class.\r\tself defineNewMethodIn: class.\r\tself defineAllocateMethodIn: class.\r\t^class',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ],		#time : DateAndTime [ '2024-12-02T14:46:22.760187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #objClassStructure,			#protocol : #'bootstrap objClass',			#sourceCode : 'objClassStructure\r\t^(Obj giveClassNamed: #ObjClass) send: #new\r\t\twithArguments: #(#(#name: #ObjClass #iv: #(#name #superclass #iv #keywords #methodDict) #superclass: #ObjObject))',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ],		#time : DateAndTime [ '2024-12-02T14:46:22.760187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #objClassStructureMessage,			#protocol : #'bootstrap objMessage',			#sourceCode : 'objClassStructureMessage\r\t^ Obj ObjClass \r\t\tsend: #new\r\t\twithArguments: #(#(#name: #ObjMessage #iv: #(#receiver #selector #arguments) #superclass: #ObjObject))',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ],		#time : DateAndTime [ '2024-12-02T14:46:22.760187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #objObjectStructure,			#protocol : #'bootstrap objObject',			#sourceCode : 'objObjectStructure\r\t^(Obj giveClassNamed: #ObjClass) \r\t\tsend: #new\r\t\twithArguments: #(#(#name: #ObjObject #iv: #(#class)))',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ],		#time : DateAndTime [ '2024-12-02T14:46:22.761187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #selectorsToSkeletonize,			#protocol : #'skeleton metadata',			#sourceCode : 'selectorsToSkeletonize\r\t"Skeletonizer new \r\t\tselectors: Obj selectorsToSkeletonize;\r\t\tsourceClassName: #Obj;\r\t\ttargetClassName: #ObjSkeleton;\r\t\tinstallClass;\r\t\tskeletonize\r\t\t"\r\r\t^ #(objIVs objIVs: objKeywords objKeywords: objMethodDict objMethodDict: objName objName: objSuperclassId objSuperclassId: objClass objClassId objClassId: allocateAnInstance offsetFromClassOfInstanceVariable: offsetFromObjectOfInstanceVariable: valueOfInstanceVariable: #send:withArguments: #super:withArguments:from: lookup: bodyOfMethod:)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ],		#time : DateAndTime [ '2024-12-02T14:46:22.761187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'addMethod:args:withBody:',			#protocol : #'method management',			#sourceCode : 'addMethod: aSelector args: aString withBody: aStringBlock \r\t"Define a method with selector <aSelector> , having a string representing the arguments (ie \'aNumber aStream\') \r\tand a string representing the method body in the receiver.\r\tIf a method with the same selector already existed, the new definition will erase it.\r\tself is an objClass"\r\r\tself  objMethodDict at: aSelector put: (self methodWithHeader: aString andBody: aStringBlock).\r\t^self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ],		#time : DateAndTime [ '2024-12-02T14:46:22.761187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'addUnaryMethod:withBody:',			#protocol : #'method management',			#sourceCode : 'addUnaryMethod: aSelector withBody: aStringBlock \r\t"Define a unary method with selector <aSelector> and a body <aaStringBlock> in the receiver.\r\tIf a method with the same selector already existed, the new definition will erase it.\r\tself is an objClass"\r\r\tself  addMethod: aSelector args: \'\' withBody: aStringBlock',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ],		#time : DateAndTime [ '2024-12-02T14:46:22.761187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r\t"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ],		#time : DateAndTime [ '2024-12-02T14:46:22.761187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'basicSend:withArguments:from:',			#protocol : #'message passing',			#sourceCode : 'basicSend: selector withArguments: arguments from: aClass\r\t"Execute the method found starting from aClass and whose name is selector."\r\t"The core of the sending a message, reused for both a normal send or a super one."\r\t\r\t| methodOrNil |\r\tmethodOrNil := aClass lookup: selector.\r\t^ methodOrNil \r\t\tifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ] \r\t\tifNil: [ self sendError: selector withArgs: arguments ] ',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ],		#time : DateAndTime [ '2024-12-02T14:46:22.762187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'blockArgsFrom:',			#protocol : #'method management',			#sourceCode : 'blockArgsFrom: aCol\r\t"self basicNew blockArgsFrom: \' abc def ghi \'"\t\r\t\r\t| col st |\r\tcol := aCol findTokens: Character space.\r\tcol := col copyWithout: \'\'.\r\tst := \'\'.\r\tcol do: [ :each | st := st , \':\', each ] separatedBy: [st := st, \' \'].\r\t^ st',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ],		#time : DateAndTime [ '2024-12-02T14:46:22.762187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ],		#time : DateAndTime [ '2024-12-02T14:46:22.762187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #classDebug,			#protocol : #debugging,			#sourceCode : 'classDebug\r\t"(self giveClassNamed: #ObjClass) classDebug"\r\r\t"(self giveClassNamed: #ObjSet) classDebug"\r\r\tObjClassInspector basicInspect: self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ],		#time : DateAndTime [ '2024-12-02T14:46:22.762187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #computeAndSetKeywords,			#protocol : #'keyword management',			#sourceCode : 'computeAndSetKeywords\r\t"Compute the keywords of a given class.  As the class of an object should not be changed.\r\t the keywords should note contain the keyword class. self is anObjClass"\r\r\tself objKeywords: (self generateKeywords: (self objIVs copyWithout: #class))',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ],		#time : DateAndTime [ '2024-12-02T14:46:22.763187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'computeNewIVFrom:with:',			#protocol : #'iv inheritance',			#sourceCode : 'computeNewIVFrom: superIVOrdCol with: localIVOrdCol\r\t"Returns an ordered collection that is the union without duplicate of ivOfSuper and ivOrderedCollection.\r\tImportant the order of the instance variable is conserved"\r\r\t| ivs |\r\t^superIVOrdCol isNil \r\t\tifTrue: [localIVOrdCol]\r\t\tifFalse: \r\t\t\t[ivs := superIVOrdCol asOrderedCollection copy.\r\t\t\tlocalIVOrdCol do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].\r\t\t\tivs]',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ],		#time : DateAndTime [ '2024-12-02T14:46:22.763187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'computeNewIVFromClass:with:',			#protocol : #'iv inheritance',			#sourceCode : 'computeNewIVFromClass: anObjClass with: ivOrderedCollection \r\t"Obj computeNewIVFromClass: #(#C #C #O #(a b c d)) with: #(a z b t) asOrderedCollection"\r\r\t| ivs |\r\t^anObjClass isNil\r\t\tifTrue: [ivOrderedCollection]\r\t\tifFalse: \r\t\t\t[ivs := anObjClass objIVs asOrderedCollection copy.\r\t\t\tivOrderedCollection do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].\r\t\t\tivs]',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ],		#time : DateAndTime [ '2024-12-02T14:46:22.763187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'doesUnderstand:',			#protocol : #'method management',			#sourceCode : 'doesUnderstand: aSelector \r\t"Tell if the receiver has a method having <aSelector> as selector. self is anObjClass"\r\r\t^self objMethodDict keys includes: aSelector',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ],		#time : DateAndTime [ '2024-12-02T14:46:22.763187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'generateKeywords:',			#protocol : #'keyword management',			#sourceCode : 'generateKeywords: anArray \r\t"Returns an array containing the keywords made from the collection of Symbol passed as argument"\r\t"self new generateKeywords: #(titi toto lulu) "\r\r\t^anArray collect: [:e | (e , \':\') asSymbol]',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ],		#time : DateAndTime [ '2024-12-02T14:46:22.763187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'initializeUsing:',			#protocol : #'instance initialization',			#sourceCode : 'initializeUsing: anAlternatedArray \r\t"Returns the receiver an ObjObject initialized according to the directives given by anAlternateArray"\r\r\t| ivValues |\r\tivValues := self \r\t\t\t\t\t\treturnValuesFrom: anAlternatedArray\r\t\t\t\t\t\tfollowingSchema: self objClass objKeywords.\r\t1 to:  ivValues size\r\t\t\tdo: [:i | self at: i + 1 put: (ivValues at: i)].\r\t^ self ',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ],		#time : DateAndTime [ '2024-12-02T14:46:22.763187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'keywordValue:getFrom:ifAbsent:',			#protocol : #'keyword management',			#sourceCode : 'keywordValue: aSymbol getFrom: anArray ifAbsent: aDefaultValue \r\t"precondition: ((length anArray) mod 2) = 0 \r\treturns the value associated with the keyword represented by aSymbol \r\tin the initarg list represented by anArray."\r\r\t"self new keywordValue: #titi getFrom: #(toto 12 titi 23) ifAbsent: 2"\r\t"self new keywordValue: #titi getFrom: #(toto 23) ifAbsent: 2"\r\r\t| i |\r\ti := anArray indexOf: aSymbol ifAbsent: nil.\r\t^i isNil \r\t\tifTrue: [aDefaultValue] \r\t\tifFalse: [anArray at: i + 1]',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ],		#time : DateAndTime [ '2024-12-02T14:46:22.764187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'lookup:',			#protocol : #'method lookup',			#sourceCode : 'lookup: selector\r\t"look for the method named <selector> starting in the receiver. \r\tThe lookup is done for a message sent to <anObjObject>. self is an objClass"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ],		#time : DateAndTime [ '2024-12-02T14:46:22.764187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'methodWithHeader:andBody:',			#protocol : #'method management',			#sourceCode : 'methodWithHeader: col andBody: aString \r\r\t| block string resBlock |\r\tstring := self stringOfBlockBodyFromHeader: col andBody: aString.\r\tblock := Compiler evaluate: string.\r\r\t"bind superclass to the superclass of the class defining the method"\r\tresBlock := block value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [666]).\r\t^resBlock',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ],		#time : DateAndTime [ '2024-12-02T14:46:22.764187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #numberOfIVs,			#protocol : #'iv management',			#sourceCode : 'numberOfIVs\r\t"Returns the number of instance variables of the class an ObjClass"\r\r\t^self objIVs size',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ],		#time : DateAndTime [ '2024-12-02T14:46:22.764187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objClass,			#protocol : #'object structure primitive',			#sourceCode : 'objClass\r\t"Receiver should be: anObjObject. Returns the class of the receiver (which is an ObjObject) and not its internal identification. Differs from classId  which is a primitive to access the structure representing a class"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ],		#time : DateAndTime [ '2024-12-02T14:46:22.768187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objClassId,			#protocol : #'object structure primitive',			#sourceCode : 'objClassId\r\t"Receiver should be: anObjObject. Returns the identifier that identifies the class of the receiver (an objObject). In this implementation we chose to use the class name as identifier"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ],		#time : DateAndTime [ '2024-12-02T14:46:22.768187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objClassId:',			#protocol : #'object structure primitive',			#sourceCode : 'objClassId: anObjClassId\r\t"Receiver should be: anObjObject. Set the identifier that identifies the class of the receiver (anObjObject)."\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ],		#time : DateAndTime [ '2024-12-02T14:46:22.768187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objIVs,			#protocol : #'class structure primitive',			#sourceCode : 'objIVs\r\t"Receiver should be: anObjClass. Returns the list of instance variables"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ],		#time : DateAndTime [ '2024-12-02T14:46:22.768187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objIVs:',			#protocol : #'class structure primitive',			#sourceCode : 'objIVs: anOrderedCollection\r\t"Receiver should be: anObjClass. Set the list of instance variable names of the receiver (anObjClass)"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ],		#time : DateAndTime [ '2024-12-02T14:46:22.769187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objKeywords,			#protocol : #'class structure primitive',			#sourceCode : 'objKeywords\r\t"Receiver should be: anObjClass. Returns the keyword list of the receiver (anObjClass)"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ],		#time : DateAndTime [ '2024-12-02T14:46:22.769187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objKeywords:',			#protocol : #'class structure primitive',			#sourceCode : 'objKeywords: anOrderedCollection\r\t"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ],		#time : DateAndTime [ '2024-12-02T14:46:22.769187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objMethodDict,			#protocol : #'class structure primitive',			#sourceCode : 'objMethodDict\r\t"Receiver should be: anObjClass. Returns the method dictionary of the receiver (anObjClass)"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ],		#time : DateAndTime [ '2024-12-02T14:46:22.769187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objMethodDict:',			#protocol : #'class structure primitive',			#sourceCode : 'objMethodDict: aDictionary\r\t"Receiver should be: anObjClass. Sets the method dictionary of the receiver (anObjClass)"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ],		#time : DateAndTime [ '2024-12-02T14:46:22.769187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objName,			#protocol : #'class structure primitive',			#sourceCode : 'objName\r\t"Receiver should be: anObjClass. Returns the name of the receiver (anObjClass)"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ],		#time : DateAndTime [ '2024-12-02T14:46:22.769187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objName:',			#protocol : #'class structure primitive',			#sourceCode : 'objName: aName\r\t"Receiver should be: anObjClass. Set the name of the receiver (anObjClass)"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ],		#time : DateAndTime [ '2024-12-02T14:46:22.770187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objSuperclass,			#protocol : #'class structure primitive',			#sourceCode : 'objSuperclass\r\t"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"\r\r\t^Obj giveClassNamed: self objSuperclassId',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '154' ],		#self : OmReference [ '155' ],		#time : DateAndTime [ '2024-12-02T14:46:22.770187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objSuperclassId,			#protocol : #'class structure primitive',			#sourceCode : 'objSuperclassId\r\t"Receiver should be: anObjClass. Returns the superclass id of the receiver (anObjClass)"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '155' ],		#self : OmReference [ '156' ],		#time : DateAndTime [ '2024-12-02T14:46:22.770187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objSuperclassId:',			#protocol : #'class structure primitive',			#sourceCode : 'objSuperclassId: anObjClassId\r\t"Receiver should be: anObjClass. Set the superclass id of the receiver (anObjClass)"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '156' ],		#self : OmReference [ '157' ],		#time : DateAndTime [ '2024-12-02T14:46:22.770187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #offsetForClass,			#protocol : #'object structure offset',			#sourceCode : 'offsetForClass\r\r\t^1',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '157' ],		#self : OmReference [ '158' ],		#time : DateAndTime [ '2024-12-02T14:46:22.770187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #offsetForIVs,			#protocol : #'class structure offset',			#sourceCode : 'offsetForIVs\r\t^4',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '158' ],		#self : OmReference [ '159' ],		#time : DateAndTime [ '2024-12-02T14:46:22.770187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #offsetForKeywords,			#protocol : #'class structure offset',			#sourceCode : 'offsetForKeywords\r\r\t^5',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '159' ],		#self : OmReference [ '160' ],		#time : DateAndTime [ '2024-12-02T14:46:22.771187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #offsetForMethodDict,			#protocol : #'class structure offset',			#sourceCode : 'offsetForMethodDict\r\r\t^6',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '160' ],		#self : OmReference [ '161' ],		#time : DateAndTime [ '2024-12-02T14:46:22.771187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #offsetForName,			#protocol : #'class structure offset',			#sourceCode : 'offsetForName\r\r\t^2',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '161' ],		#self : OmReference [ '162' ],		#time : DateAndTime [ '2024-12-02T14:46:22.771187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #offsetForSuperclass,			#protocol : #'class structure offset',			#sourceCode : 'offsetForSuperclass\r\r\t^3',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '162' ],		#self : OmReference [ '163' ],		#time : DateAndTime [ '2024-12-02T14:46:22.771187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'offsetFromClassOfInstanceVariable:',			#protocol : #'iv management',			#sourceCode : 'offsetFromClassOfInstanceVariable: aSymbol\r\t"Returns the index of the instance variable named aSymbol for an class anObjClass.\r\tReturns 0 if the aSymbol is not present in the instance variable lists of anObjClass"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '163' ],		#self : OmReference [ '164' ],		#time : DateAndTime [ '2024-12-02T14:46:22.771187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'offsetFromObjectOfInstanceVariable:',			#protocol : #'keyword management',			#sourceCode : 'offsetFromObjectOfInstanceVariable: aSymbol\r\t"Returns the offset of the instance variable named aSymbol in the object anObjObject.\r\tIf aSymbol is not an instance variable is not an instance variable of the object raise an error"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '164' ],		#self : OmReference [ '165' ],		#time : DateAndTime [ '2024-12-02T14:46:22.772187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\r\taStream nextPutAll: \'an Obj object: \'.\t\r\tsuper printOn: aStream',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '165' ],		#self : OmReference [ '166' ],		#time : DateAndTime [ '2024-12-02T14:46:22.772187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'removeMethod:',			#protocol : #'method management',			#sourceCode : 'removeMethod: aSelector\r\t"Remove the method with aSelector <aSymbol> in the receiver. \r\tself is an objClass"\r\r\tself objMethodDict removeKey: aSelector ifAbsent: [].\r\t^self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '166' ],		#self : OmReference [ '167' ],		#time : DateAndTime [ '2024-12-02T14:46:22.772187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'returnValuesFrom:followingSchema:',			#protocol : #'keyword management',			#sourceCode : 'returnValuesFrom: anInitargArray followingSchema: anArrayOfKeywords \r\t"Return the values associated with the keys. The extracted values are taken from <anInitargArray> \r\tand the return values are extracted according to the schema defined by the collection of keys <anArrayOfKeywords>"\r\r\t"self new returnValuesFrom: #(lulu 22  titi 35)  followingSchema: #(titi toto lulu titi)  #(35 nil 22 35)"\r\r\t^anArrayOfKeywords collect: \r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '167' ],		#self : OmReference [ '168' ],		#time : DateAndTime [ '2024-12-02T14:46:22.775187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'send:withArguments:',			#protocol : #'message passing',			#sourceCode : 'send: selector withArguments: arguments\r\t"send the message whose selector is <selector> to the receiver. The arguments of the messages are an array <arguments>. The method is lookep up in the class of the receiver. self is an objObject or a objClass."\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '168' ],		#self : OmReference [ '169' ],		#time : DateAndTime [ '2024-12-02T14:46:22.775187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'sendError:withArgs:',			#protocol : #'message passing',			#sourceCode : 'sendError: selector withArgs: arguments\r\t"send error wrapping arguments into an array with the selector as first argument. Instead of an array we should create a message object."\r\t\r\t^ self send: #error withArguments:  {(arguments copyWithFirst: selector)}\r\t\r',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '169' ],		#self : OmReference [ '170' ],		#time : DateAndTime [ '2024-12-02T14:46:22.776187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'stringOfBlockBodyFromHeader:andBody:',			#protocol : #'method management',			#sourceCode : 'stringOfBlockBodyFromHeader: col andBody: aString \r\t^ \'[ :superClassOfClassDefiningTheMethod |\r\t\t[ :objself \' , (self blockArgsFrom: col) , \' |\r\t\t\t\t\t \' , aString , \'] ]\'',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '170' ],		#self : OmReference [ '171' ],		#time : DateAndTime [ '2024-12-02T14:46:22.776187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'super:withArguments:from:',			#protocol : #'message passing',			#sourceCode : 'super: selector withArguments: arguments from: aSuperclass\r\t"Invoke an oveeriden method named <selector> with an array of arguments <arguments>.  self is an objClass. aSuperclass should be the superclass of the class containing the method using super"\r\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '171' ],		#self : OmReference [ '172' ],		#time : DateAndTime [ '2024-12-02T14:46:22.776187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'valueOfInstanceVariable:',			#protocol : #'iv management',			#sourceCode : 'valueOfInstanceVariable: aSymbol\r\t^ self',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '172' ],		#self : OmReference [ '173' ],		#time : DateAndTime [ '2024-12-02T14:46:22.776187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StrictlyOrderedEyeElement,				#isMetaSide : false			},			#name : #orderedStructure,			#protocol : #accessing,			#sourceCode : 'orderedStructure\r\t\r\t^ orderedStructure',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '173' ],		#self : OmReference [ '174' ],		#time : DateAndTime [ '2024-12-02T14:46:22.776187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StrictlyOrderedEyeElement,				#isMetaSide : false			},			#name : #'orderedStructure:',			#protocol : #accessing,			#sourceCode : 'orderedStructure: anObject\r\t\r\torderedStructure := anObject',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '174' ],		#self : OmReference [ '175' ],		#time : DateAndTime [ '2024-12-02T14:46:22.777187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #StrictlyOrderedEyeElement,				#isMetaSide : false			},			#name : #value,			#protocol : #accessing,			#sourceCode : 'value\r\t^ self host basicAt: (self orderedStructure indexOf: index)',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#prior : OmReference [ '175' ],		#self : OmReference [ '176' ],		#time : DateAndTime [ '2024-12-02T14:46:22.777187+01:00' ],		#trigger : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjClassInspector,				#isMetaSide : false			},			#name : #'addVariableFields:',			#protocol : #list,			#sourceCode : 'addVariableFields: elements\r\t\r\t| classStructure |\r\tclassStructure := Obj classInstanceVariables.\r\tclassStructure do: [ :key |\r\t\telements add: (StrictlyOrderedEyeElement new \r\t\t\t\t\t\t\t\torderedStructure: classStructure;\r\t\t\t\t\t\t\t\thost: self object;\r\t\t\t\t\t\t\t\tindex: key; \r\t\t\t\t\t\t\t\tyourself)]',			#stamp : '',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:06:17.569187+01:00' ],		#prior : OmReference [ '176' ],		#self : OmReference [ '177' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objClassId,			#protocol : #'object structure primitive',			#sourceCode : 'objClassId\r\t"Receiver should be: anObjObject. Returns the identifier that identifies the class of the receiver (an objObject). In this implementation we chose to use the class name as identifier"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objClassId,			#protocol : #'object structure primitive',			#sourceCode : 'objClassId\r\t"Receiver should be: anObjObject. Returns the identifier that identifies the class of the receiver (an objObject). In this implementation we chose to use the class name as identifier"\r\r\t^ self at: self offsetForClass\r\t\r\t',			#stamp : 'Anonymous 12/2/2024 15:06',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:07:45.072187+01:00' ],		#prior : OmReference [ '177' ],		#self : OmReference [ '178' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objClassId:',			#protocol : #'object structure primitive',			#sourceCode : 'objClassId: anObjClassId\r\t"Receiver should be: anObjObject. Set the identifier that identifies the class of the receiver (anObjObject)."\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objClassId:',			#protocol : #'object structure primitive',			#sourceCode : 'objClassId: anObjClassId\r\t"Receiver should be: anObjObject. Set the identifier that identifies the class of the receiver (anObjObject)."\r\r\t^ self at: self offsetForClass put: anObjClassId .',			#stamp : 'Anonymous 12/2/2024 15:07',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:13:37.513187+01:00' ],		#prior : OmReference [ '178' ],		#self : OmReference [ '179' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objName,			#protocol : #'class structure primitive',			#sourceCode : 'objName\r\t"Receiver should be: anObjClass. Returns the name of the receiver (anObjClass)"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objName,			#protocol : #'class structure primitive',			#sourceCode : 'objName\r\t"Receiver should be: anObjClass. Returns the name of the receiver (anObjClass)"\r\r\t^ self at: self offsetForName .\r',			#stamp : 'Anonymous 12/2/2024 15:13',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:16:14.826187+01:00' ],		#prior : OmReference [ '179' ],		#self : OmReference [ '180' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objName:',			#protocol : #'class structure primitive',			#sourceCode : 'objName: aName\r\t"Receiver should be: anObjClass. Set the name of the receiver (anObjClass)"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objName:',			#protocol : #'class structure primitive',			#sourceCode : 'objName: aName\r\t"Receiver should be: anObjClass. Set the name of the receiver (anObjClass)"\r\r\t^ self at: self offsetForName put: aName ',			#stamp : 'Anonymous 12/2/2024 15:16',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:16:36.373187+01:00' ],		#prior : OmReference [ '180' ],		#self : OmReference [ '181' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objSuperclassId,			#protocol : #'class structure primitive',			#sourceCode : 'objSuperclassId\r\t"Receiver should be: anObjClass. Returns the superclass id of the receiver (anObjClass)"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objSuperclassId,			#protocol : #'class structure primitive',			#sourceCode : 'objSuperclassId\r\t"Receiver should be: anObjClass. Returns the superclass id of the receiver (anObjClass)"\r\r\t^ self at: self offsetForSuperclass .',			#stamp : 'Anonymous 12/2/2024 15:16',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:17:08.235187+01:00' ],		#prior : OmReference [ '181' ],		#self : OmReference [ '182' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objSuperclassId:',			#protocol : #'class structure primitive',			#sourceCode : 'objSuperclassId: anObjClassId\r\t"Receiver should be: anObjClass. Set the superclass id of the receiver (anObjClass)"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objSuperclassId:',			#protocol : #'class structure primitive',			#sourceCode : 'objSuperclassId: anObjClassId\r\t"Receiver should be: anObjClass. Set the superclass id of the receiver (anObjClass)"\r\r\t^ self at: self offsetForSuperclass put: anObjClassId .\r',			#stamp : 'Anonymous 12/2/2024 15:17',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:18:07.510187+01:00' ],		#prior : OmReference [ '182' ],		#self : OmReference [ '183' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objSuperclass,			#protocol : #'class structure primitive',			#sourceCode : 'objSuperclass\r\t"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"\r\r\t^Obj giveClassNamed: self objSuperclassId',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objSuperclass,			#protocol : #'class structure primitive',			#sourceCode : 'objSuperclass\r\t"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"\r\r\t^self giveClassNamed: self objSuperclassId',			#stamp : 'Anonymous 12/2/2024 15:18',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:19:18.700187+01:00' ],		#prior : OmReference [ '183' ],		#self : OmReference [ '184' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objSuperclass,			#protocol : #'class structure primitive',			#sourceCode : 'objSuperclass\r\t"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"\r\r\t^self giveClassNamed: self objSuperclassId',			#stamp : 'Anonymous 12/2/2024 15:18',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objSuperclass,			#protocol : #'class structure primitive',			#sourceCode : 'objSuperclass\r\t"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"\r\r\t^Obj  giveClassNamed: self objSuperclassId',			#stamp : 'Anonymous 12/2/2024 15:19',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:20:29.264187+01:00' ],		#prior : OmReference [ '184' ],		#self : OmReference [ '185' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objIVs,			#protocol : #'class structure primitive',			#sourceCode : 'objIVs\r\t"Receiver should be: anObjClass. Returns the list of instance variables"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objIVs,			#protocol : #'class structure primitive',			#sourceCode : 'objIVs\r\t"Receiver should be: anObjClass. Returns the list of instance variables"\r\r\t^ self at: self offsetForIVs',			#stamp : 'Anonymous 12/2/2024 15:20',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:20:49.788187+01:00' ],		#prior : OmReference [ '185' ],		#self : OmReference [ '186' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objIVs:',			#protocol : #'class structure primitive',			#sourceCode : 'objIVs: anOrderedCollection\r\t"Receiver should be: anObjClass. Set the list of instance variable names of the receiver (anObjClass)"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objIVs:',			#protocol : #'class structure primitive',			#sourceCode : 'objIVs: anOrderedCollection\r\t"Receiver should be: anObjClass. Set the list of instance variable names of the receiver (anObjClass)"\r\r\t^ self at: self offsetForIVs put: anOrderedCollection .\r',			#stamp : 'Anonymous 12/2/2024 15:20',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:22:25.385187+01:00' ],		#prior : OmReference [ '186' ],		#self : OmReference [ '187' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objKeywords:',			#protocol : #'class structure primitive',			#sourceCode : 'objKeywords: anOrderedCollection\r\t"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objKeywords:',			#protocol : #'class structure primitive',			#sourceCode : 'objKeywords: anOrderedCollection\r\t"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"\r\r\t^ self at: self offsetForKeywords put: anOrderedCollection .\r',			#stamp : 'Anonymous 12/2/2024 15:22',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:22:46.597187+01:00' ],		#prior : OmReference [ '187' ],		#self : OmReference [ '188' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objMethodDict,			#protocol : #'class structure primitive',			#sourceCode : 'objMethodDict\r\t"Receiver should be: anObjClass. Returns the method dictionary of the receiver (anObjClass)"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objMethodDict,			#protocol : #'class structure primitive',			#sourceCode : 'objMethodDict\r\t"Receiver should be: anObjClass. Returns the method dictionary of the receiver (anObjClass)"\r\r\t^ self at: self offsetForMethodDict .',			#stamp : 'Anonymous 12/2/2024 15:22',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:23:01.370187+01:00' ],		#prior : OmReference [ '188' ],		#self : OmReference [ '189' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objMethodDict:',			#protocol : #'class structure primitive',			#sourceCode : 'objMethodDict: aDictionary\r\t"Receiver should be: anObjClass. Sets the method dictionary of the receiver (anObjClass)"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objMethodDict:',			#protocol : #'class structure primitive',			#sourceCode : 'objMethodDict: aDictionary\r\t"Receiver should be: anObjClass. Sets the method dictionary of the receiver (anObjClass)"\r\r\t^ self at: self offsetForMethodDict put: aDictionary .',			#stamp : 'Anonymous 12/2/2024 15:23',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:24:39.615187+01:00' ],		#prior : OmReference [ '189' ],		#self : OmReference [ '190' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testClassAccess,			#protocol : #'step3-tests-class access',			#sourceCode : 'testClassAccess\r\t"(self  selector: #testClassAccess) run"\r\t\r\tself assert: (aPoint objClass = pointClass)',			#stamp : 'StephaneDucasse 11/17/2014 11:09',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testClassAccess,			#protocol : #'step3-tests-class access',			#sourceCode : 'testClassAccess\r\t"(self  selector: #testClassAccess) run"\r\t\r\tself assert: (pointClass objClassId = #ObjClass)',			#stamp : 'Anonymous 12/2/2024 15:24',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:30:32.034187+01:00' ],		#prior : OmReference [ '190' ],		#self : OmReference [ '191' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjKeywords,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjKeywords\r\t"(self selector: #testPrimitiveStructureObjKeywords) run"\r\r\tself assert: ((pointClass objKeywords) = #(#x: #y:)).\r',			#stamp : 'StephaneDucasse 11/17/2014 11:09',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjKeywords,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjKeywords\r\t"(self selector: #testPrimitiveStructureObjKeywords) run"\r\r\tself assert: ((pointClass objKeywords) ==#(#x: #y:)).\r',			#stamp : 'Anonymous 12/2/2024 15:30',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:30:46.566187+01:00' ],		#prior : OmReference [ '191' ],		#self : OmReference [ '192' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjKeywords,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjKeywords\r\t"(self selector: #testPrimitiveStructureObjKeywords) run"\r\r\tself assert: ((pointClass objKeywords) ==#(#x: #y:)).\r',			#stamp : 'Anonymous 12/2/2024 15:30',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RawObjTest,				#isMetaSide : false			},			#name : #testPrimitiveStructureObjKeywords,			#protocol : #'step2-tests-structure of classes',			#sourceCode : 'testPrimitiveStructureObjKeywords\r\t"(self selector: #testPrimitiveStructureObjKeywords) run"\r\r\tself assert: ((pointClass objKeywords) =#(#x: #y:)).\r',			#stamp : 'Anonymous 12/2/2024 15:30',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:35:24.275187+01:00' ],		#prior : OmReference [ '192' ],		#self : OmReference [ '193' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objKeywords:',			#protocol : #'class structure primitive',			#sourceCode : 'objKeywords: anOrderedCollection\r\t"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"\r\r\t^ self at: self offsetForKeywords put: anOrderedCollection .\r',			#stamp : 'Anonymous 12/2/2024 15:22',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'objKeywords:',			#protocol : #'class structure primitive',			#sourceCode : 'objKeywords: anOrderedCollection\r\t"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"\r\r\t^ self at: self offsetForKeywords put: anOrderedCollection.\r',			#stamp : 'Anonymous 12/2/2024 15:35',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:43:58.311187+01:00' ],		#prior : OmReference [ '193' ],		#self : OmReference [ '194' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objKeywords,			#protocol : #'class structure primitive',			#sourceCode : 'objKeywords\r\t"Receiver should be: anObjClass. Returns the keyword list of the receiver (anObjClass)"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objKeywords,			#protocol : #'class structure primitive',			#sourceCode : 'objKeywords\r\t"Receiver should be: anObjClass. Returns the keyword list of the receiver (anObjClass)"\r\r\t^ self at: self offsetForKeywords.',			#stamp : 'Anonymous 12/2/2024 15:43',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T15:53:53.159187+01:00' ],		#prior : OmReference [ '194' ],		#self : OmReference [ '195' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objClass,			#protocol : #'object structure primitive',			#sourceCode : 'objClass\r\t"Receiver should be: anObjObject. Returns the class of the receiver (which is an ObjObject) and not its internal identification. Differs from classId  which is a primitive to access the structure representing a class"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #objClass,			#protocol : #'object structure primitive',			#sourceCode : 'objClass\r\t"Receiver should be: anObjObject. Returns the class of the receiver (which is an ObjObject) and not its internal identification. Differs from classId  which is a primitive to access the structure representing a class"\r\r\t^ Obj giveClassNamed: self objClassId .\r',			#stamp : 'Anonymous 12/2/2024 15:53',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:19:05.454187+01:00' ],		#prior : OmReference [ '195' ],		#self : OmReference [ '196' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'offsetFromClassOfInstanceVariable:',			#protocol : #'iv management',			#sourceCode : 'offsetFromClassOfInstanceVariable: aSymbol\r\t"Returns the index of the instance variable named aSymbol for an class anObjClass.\r\tReturns 0 if the aSymbol is not present in the instance variable lists of anObjClass"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'offsetFromClassOfInstanceVariable:',			#protocol : #'iv management',			#sourceCode : 'offsetFromClassOfInstanceVariable: aSymbol\r\t"Returns the index of the instance variable named aSymbol for an class anObjClass.\r\tReturns 0 if the aSymbol is not present in the instance variable lists of anObjClass"\r\r\t| listIV index |\rlistIV := self objIVs .\rindex := listIV indexOf: aSymbol .\r^ index ifNotNil: [ index ] ifNil: [ 0 ].',			#stamp : 'Anonymous 12/2/2024 16:19',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:24:50.666187+01:00' ],		#prior : OmReference [ '196' ],		#self : OmReference [ '197' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'offsetFromObjectOfInstanceVariable:',			#protocol : #'keyword management',			#sourceCode : 'offsetFromObjectOfInstanceVariable: aSymbol\r\t"Returns the offset of the instance variable named aSymbol in the object anObjObject.\r\tIf aSymbol is not an instance variable is not an instance variable of the object raise an error"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'offsetFromObjectOfInstanceVariable:',			#protocol : #'keyword management',			#sourceCode : 'offsetFromObjectOfInstanceVariable: aSymbol\r\t"Returns the offset of the instance variable named aSymbol in the object anObjObject.\r\tIf aSymbol is not an instance variable is not an instance variable of the object raise an error"\r\r\t| offset |\roffset := self objClass offsetFromClassOfInstanceVariable:\raSymbol .\roffset = 0 ifTrue:\r[ ^ self error: \'Variable dinstance non definie: \',\raSymbol asString ].\r^ offset',			#stamp : 'Anonymous 12/2/2024 16:24',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:30:08.942187+01:00' ],		#prior : OmReference [ '197' ],		#self : OmReference [ '198' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'valueOfInstanceVariable:',			#protocol : #'iv management',			#sourceCode : 'valueOfInstanceVariable: aSymbol\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'valueOfInstanceVariable:',			#protocol : #'iv management',			#sourceCode : 'valueOfInstanceVariable: aSymbol\r\t^ self valueOfInstanceVariable: aSymbol',			#stamp : 'Anonymous 12/2/2024 16:30',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:35:24.013187+01:00' ],		#prior : OmReference [ '198' ],		#self : OmReference [ '199' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r\t"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r\t"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "\r\r\t   "Alloue une nouvelle instance de la classe actuelle"\r    ^ Array with: self name with: nil with: nil.',			#stamp : 'Anonymous 12/2/2024 16:35',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:37:41.523187+01:00' ],		#prior : OmReference [ '199' ],		#self : OmReference [ '200' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r\t"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "\r\r\t   "Alloue une nouvelle instance de la classe actuelle"\r    ^ Array with: self name with: nil with: nil.',			#stamp : 'Anonymous 12/2/2024 16:35',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Retourne une nouvelle instance de la classe avec ses variables d\'instance initialisées à nil."\r    \r    | instanceSize newInstance |\r    \r    instanceSize := self ivs size + 1. "Taille de l\'instance = 1 pour le nom de la classe + variables d\'instance"\r    newInstance := Array new: instanceSize. "Crée un tableau de la taille appropriée"\r    \r    newInstance at: 1 put: self name. "Le premier élément est le nom de la classe"\r    \r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:37',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:38:15.704187+01:00' ],		#prior : OmReference [ '200' ],		#self : OmReference [ '201' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Retourne une nouvelle instance de la classe avec ses variables d\'instance initialisées à nil."\r    \r    | instanceSize newInstance |\r    \r    instanceSize := self ivs size + 1. "Taille de l\'instance = 1 pour le nom de la classe + variables d\'instance"\r    newInstance := Array new: instanceSize. "Crée un tableau de la taille appropriée"\r    \r    newInstance at: 1 put: self name. "Le premier élément est le nom de la classe"\r    \r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:37',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r\t"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "\r\r\t   "Alloue une nouvelle instance de la classe actuelle"\r    ^self',			#stamp : 'Anonymous 12/2/2024 16:38',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:43:20.253187+01:00' ],		#prior : OmReference [ '201' ],		#self : OmReference [ '202' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r\t"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "\r\r\t   "Alloue une nouvelle instance de la classe actuelle"\r    ^self',			#stamp : 'Anonymous 12/2/2024 16:38',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Créer une nouvelle instance de la classe actuelle avec ses variables d\'instance initialisées à nil"\r    \r    | instanceSize newInstance |\r    \r    "1. Calculer la taille de l\'instance"\r    instanceSize := self ivs size + 1.\r    \r    "2. Créer un tableau vide de cette taille"\r    newInstance := Array new: instanceSize.\r    \r    "3. Ajouter l\'identifiant de la classe comme premier élément"\r    newInstance at: 1 put: self name.\r    \r    "4. Retourner cette nouvelle instance"\r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:43',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:44:37.286187+01:00' ],		#prior : OmReference [ '202' ],		#self : OmReference [ '203' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Créer une nouvelle instance de la classe actuelle avec ses variables d\'instance initialisées à nil"\r    \r    | instanceSize newInstance |\r    \r    "1. Calculer la taille de l\'instance"\r    instanceSize := self ivs size + 1.\r    \r    "2. Créer un tableau vide de cette taille"\r    newInstance := Array new: instanceSize.\r    \r    "3. Ajouter l\'identifiant de la classe comme premier élément"\r    newInstance at: 1 put: self name.\r    \r    "4. Retourner cette nouvelle instance"\r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:43',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Créer une nouvelle instance de la classe actuelle avec ses variables d\'instance initialisées à nil"\r    ^self\r',			#stamp : 'Anonymous 12/2/2024 16:44',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:48:22.742187+01:00' ],		#prior : OmReference [ '203' ],		#self : OmReference [ '204' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Créer une nouvelle instance de la classe actuelle avec ses variables d\'instance initialisées à nil"\r    ^self\r',			#stamp : 'Anonymous 12/2/2024 16:44',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Créer une nouvelle instance de la classe actuelle avec ses variables d\'instance initialisées à nil"\r    \r    | instanceSize newInstance |\r    \r    "1. Calculer la taille de l\'instance"\r    instanceSize := self objIVs  size + 1.\r    \r    "2. Créer un tableau vide de cette taille"\r    newInstance := Array new: instanceSize.\r    \r    "3. Ajouter l\'identifiant de la classe comme premier élément"\r    newInstance at: 1 put: self name.\r    \r    "4. Retourner cette nouvelle instance"\r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:48',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:49:08.425187+01:00' ],		#prior : OmReference [ '204' ],		#self : OmReference [ '205' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Créer une nouvelle instance de la classe actuelle avec ses variables d\'instance initialisées à nil"\r    \r    | instanceSize newInstance |\r    \r    "1. Calculer la taille de l\'instance"\r    instanceSize := self objIVs  size + 1.\r    \r    "2. Créer un tableau vide de cette taille"\r    newInstance := Array new: instanceSize.\r    \r    "3. Ajouter l\'identifiant de la classe comme premier élément"\r    newInstance at: 1 put: self name.\r    \r    "4. Retourner cette nouvelle instance"\r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:48',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Créer une nouvelle instance de la classe actuelle avec ses variables d\'instance initialisées à nil"\r    \r    | instanceSize newInstance |\r    \r    "1. Calculer la taille de l\'instance"\r    instanceSize := self objIVs  size + 1.\r    \r    "2. Créer un tableau vide de cette taille"\r    newInstance := Array new: instanceSize.\r    \r    "3. Ajouter l\'identifiant de la classe comme premier élément"\r    newInstance at: 1 put: self objName .\r    \r    "4. Retourner cette nouvelle instance"\r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:49',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:55:25.951187+01:00' ],		#prior : OmReference [ '205' ],		#self : OmReference [ '206' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Créer une nouvelle instance de la classe actuelle avec ses variables d\'instance initialisées à nil"\r    \r    | instanceSize newInstance |\r    \r    "1. Calculer la taille de l\'instance"\r    instanceSize := self objIVs  size + 1.\r    \r    "2. Créer un tableau vide de cette taille"\r    newInstance := Array new: instanceSize.\r    \r    "3. Ajouter l\'identifiant de la classe comme premier élément"\r    newInstance at: 1 put: self objName .\r    \r    "4. Retourner cette nouvelle instance"\r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:49',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    | instanceSize newInstance |\r    \r    instanceSize := self objIVs size + 1.\r    Transcript show: \'Instance size: \', instanceSize printString; cr.\r    \r    newInstance := Array new: instanceSize.\r    newInstance at: 1 put: self objName.\r    Transcript show: \'New instance: \', newInstance printString; cr.\r    \r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:55',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T16:57:52.776187+01:00' ],		#prior : OmReference [ '206' ],		#self : OmReference [ '207' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    | instanceSize newInstance |\r    \r    instanceSize := self objIVs size + 1.\r    Transcript show: \'Instance size: \', instanceSize printString; cr.\r    \r    newInstance := Array new: instanceSize.\r    newInstance at: 1 put: self objName.\r    Transcript show: \'New instance: \', newInstance printString; cr.\r    \r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:55',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Créer une nouvelle instance de la classe actuelle avec ses variables d\'instance initialisées à nil"\r\r    | instanceSize newInstance |\r    \r    "1. Calculer la taille de l\'instance : nombre de variables d\'instance + 1 (pour l\'identifiant de classe)"\r    instanceSize := self objIVs size + 1.\r\r    "2. Créer un tableau vide de cette taille"\r    newInstance := Array new: instanceSize.\r\r    "3. Ajouter l\'identifiant de la classe (le nom de la classe) comme premier élément"\r    newInstance at: 1 put: self objName.\r\r    "4. Initialiser toutes les variables d\'instance à nil"\r    2 to: instanceSize do: [:index | newInstance at: index put: nil].\r\r    "5. Retourner l\'instance nouvellement créée"\r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:57',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:05:45.630187+01:00' ],		#prior : OmReference [ '207' ],		#self : OmReference [ '208' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Créer une nouvelle instance de la classe actuelle avec ses variables d\'instance initialisées à nil"\r\r    | instanceSize newInstance |\r    \r    "1. Calculer la taille de l\'instance : nombre de variables d\'instance + 1 (pour l\'identifiant de classe)"\r    instanceSize := self objIVs size + 1.\r\r    "2. Créer un tableau vide de cette taille"\r    newInstance := Array new: instanceSize.\r\r    "3. Ajouter l\'identifiant de la classe (le nom de la classe) comme premier élément"\r    newInstance at: 1 put: self objName.\r\r    "4. Initialiser toutes les variables d\'instance à nil"\r    2 to: instanceSize do: [:index | newInstance at: index put: nil].\r\r    "5. Retourner l\'instance nouvellement créée"\r    ^ newInstance\r',			#stamp : 'Anonymous 12/2/2024 16:57',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #allocateAnInstance,			#protocol : #'instance allocation',			#sourceCode : 'allocateAnInstance\r    "Créer une nouvelle instance de la classe actuelle avec ses variables d\'instance initialisées à nil"\r\r    |newInstance |\r\rnewInstance:= Obj new:( self numberOfIVs).\rnewInstance objClassId:(self objName).\r^newInstance\r    \r   ',			#stamp : 'Anonymous 12/2/2024 17:05',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:21:22.018187+01:00' ],		#prior : OmReference [ '208' ],		#self : OmReference [ '209' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r\r\t^ self objMethodDict at: aSelector ifAbsent: [ nil ]',			#stamp : 'Anonymous 12/2/2024 17:21',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:23:26.758187+01:00' ],		#prior : OmReference [ '209' ],		#self : OmReference [ '210' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r\r\t^ self objMethodDict at: aSelector ifAbsent: [ nil ]',			#stamp : 'Anonymous 12/2/2024 17:21',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r\r\t (self doesUnderstand: aSelector)\r        ifTrue: [^ self methodDictionary at: aSelector]\r        ifFalse: [^ nil].',			#stamp : 'Anonymous 12/2/2024 17:23',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:23:56.298187+01:00' ],		#prior : OmReference [ '210' ],		#self : OmReference [ '211' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r\r\t (self doesUnderstand: aSelector)\r        ifTrue: [^ self methodDictionary at: aSelector]\r        ifFalse: [^ nil].',			#stamp : 'Anonymous 12/2/2024 17:23',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r\r\t (self doesUnderstand: aSelector)\r        ifTrue: [^ self method at: aSelector]\r        ifFalse: [^ nil].',			#stamp : 'Anonymous 12/2/2024 17:23',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:24:55.905187+01:00' ],		#prior : OmReference [ '211' ],		#self : OmReference [ '212' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r\r\t (self doesUnderstand: aSelector)\r        ifTrue: [^ self method at: aSelector]\r        ifFalse: [^ nil].',			#stamp : 'Anonymous 12/2/2024 17:23',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r(self doesUnderstand: aSelector)\r        ifTrue: [^ self methodDictionary at: aSelector]\r        ifFalse: [^ nil].',			#stamp : 'Anonymous 12/2/2024 17:24',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:25:42.789187+01:00' ],		#prior : OmReference [ '212' ],		#self : OmReference [ '213' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r(self doesUnderstand: aSelector)\r        ifTrue: [^ self methodDictionary at: aSelector]\r        ifFalse: [^ nil].',			#stamp : 'Anonymous 12/2/2024 17:24',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r^self objMethodDict at: aSelector ifAbsent: [ nil ]',			#stamp : 'Anonymous 12/2/2024 17:25',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:28:17.565187+01:00' ],		#prior : OmReference [ '213' ],		#self : OmReference [ '214' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r\t"Return the method associated with the selector <aSelector> in the receiver.\r\tReturn nil if the selector is not defined.  self is an objClass"\r^self objMethodDict at: aSelector ifAbsent: [ nil ]',			#stamp : 'Anonymous 12/2/2024 17:25',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r    \r    | method |\r    \r    "Vérifier si la méthode est dans le dictionnaire des méthodes"\r    method := self methodDictionary at: aSelector ifAbsent: [nil].\r    \r    "Retourner le bloc de la méthode"\r    ^ method.\r',			#stamp : 'Anonymous 12/2/2024 17:28',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:33:26.037187+01:00' ],		#prior : OmReference [ '214' ],		#self : OmReference [ '215' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #setup,			#sourceCode : 'setUp\r\t"self new setUp"\r\r\tObj initialize.\r\tself assembleClassClass.\r\tself assemblePointClass.\r\tself assembleObjectClass.\r\tself assembleColoredPointClass.\r\tself assemblePointInstance.\r\tself assembleColoredInstance.\r\tself assembleIncrementalColoredInstance.\r\tself assembleIncrementalColoredPointClass',			#stamp : 'StephaneDucasse 2/15/2011 16:15',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ObjTest,				#isMetaSide : false			},			#name : #setUp,			#protocol : #setup,			#sourceCode : 'setUp\r\t"self new setUp"\r   Compiler := OpalCompiler.\r\tObj initialize.\r\tself assembleClassClass.\r\tself assemblePointClass.\r\tself assembleObjectClass.\r\tself assembleColoredPointClass.\r\tself assemblePointInstance.\r\tself assembleColoredInstance.\r\tself assembleIncrementalColoredInstance.\r\tself assembleIncrementalColoredPointClass',			#stamp : 'Anonymous 12/2/2024 17:33',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:35:18.809187+01:00' ],		#prior : OmReference [ '215' ],		#self : OmReference [ '216' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r    \r    | method |\r    \r    "Vérifier si la méthode est dans le dictionnaire des méthodes"\r    method := self methodDictionary at: aSelector ifAbsent: [nil].\r    \r    "Retourner le bloc de la méthode"\r    ^ method.\r',			#stamp : 'Anonymous 12/2/2024 17:28',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r   ^self objMethodDict at: aSelector ifAbsent: [ nil ]',			#stamp : 'Anonymous 12/2/2024 17:35',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'AutoDeprecationRefactoring',		#time : DateAndTime [ '2024-12-02T17:35:35.582187+01:00' ],		#prior : OmReference [ '216' ],		#self : OmReference [ '217' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'methodWithHeader:andBody:',			#protocol : #'method management',			#sourceCode : 'methodWithHeader: col andBody: aString \r\r\t| block string resBlock |\r\tstring := self stringOfBlockBodyFromHeader: col andBody: aString.\r\tblock := Compiler evaluate: string.\r\r\t"bind superclass to the superclass of the class defining the method"\r\tresBlock := block value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [666]).\r\t^resBlock',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'methodWithHeader:andBody:',			#protocol : #'method management',			#sourceCode : 'methodWithHeader: col andBody: aString\r\t| block string resBlock |\r\tstring := self stringOfBlockBodyFromHeader: col andBody: aString.\r\tblock := Compiler new\r\t\tsource: string;\r\t\tevaluate.\r\r\t"bind superclass to the superclass of the class defining the method"\r\tresBlock := block\r\t\tvalue: (Obj giveClassNamed: self objSuperclassId ifAbsent: [ 666 ]).\r\t^ resBlock',			#stamp : 'AutoDeprecationRefactoring 12/2/2024 17:35',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:38:04.719187+01:00' ],		#prior : OmReference [ '217' ],		#self : OmReference [ '218' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r   ^self objMethodDict at: aSelector ifAbsent: [ nil ]',			#stamp : 'Anonymous 12/2/2024 17:35',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r   ^self objMethodDict at: aSelector ifAbsent: [ \r\tself error: \'Method non trouvé : \', aSelector asString  ].',			#stamp : 'Anonymous 12/2/2024 17:38',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:44:45.649187+01:00' ],		#prior : OmReference [ '218' ],		#self : OmReference [ '219' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r   ^self objMethodDict at: aSelector ifAbsent: [ \r\tself error: \'Method non trouvé : \', aSelector asString  ].',			#stamp : 'Anonymous 12/2/2024 17:38',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector \r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r   ^self objMethodDict at: aSelector .',			#stamp : 'Anonymous 12/2/2024 17:44',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:47:01.391187+01:00' ],		#prior : OmReference [ '219' ],		#self : OmReference [ '220' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector \r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r   ^self objMethodDict at: aSelector .',			#stamp : 'Anonymous 12/2/2024 17:44',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector \r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r   ^self objMethodDict at: aSelector ',			#stamp : 'Anonymous 12/2/2024 17:47',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:49:04.297187+01:00' ],		#prior : OmReference [ '220' ],		#self : OmReference [ '221' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector \r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r   ^self objMethodDict at: aSelector ',			#stamp : 'Anonymous 12/2/2024 17:47',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: args1 \r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r   ^self objMethodDict at: args1 ',			#stamp : 'Anonymous 12/2/2024 17:49',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:53:27.276187+01:00' ],		#prior : OmReference [ '221' ],		#self : OmReference [ '222' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: args1 \r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r   ^self objMethodDict at: args1 ',			#stamp : 'Anonymous 12/2/2024 17:49',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r    ^self objMethodDict at: aSelector ifAbsent: [nil].\r',			#stamp : 'Anonymous 12/2/2024 17:53',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:55:59.492187+01:00' ],		#prior : OmReference [ '222' ],		#self : OmReference [ '223' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r    ^self objMethodDict at: aSelector ifAbsent: [nil].\r',			#stamp : 'Anonymous 12/2/2024 17:53',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r    ^ self objMethodDict at: aSelector .\r',			#stamp : 'Anonymous 12/2/2024 17:55',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T17:59:32.411187+01:00' ],		#prior : OmReference [ '223' ],		#self : OmReference [ '224' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r    ^ self objMethodDict at: aSelector .\r',			#stamp : 'Anonymous 12/2/2024 17:55',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r    ^ self objMethodDict at: aSelector ifAbsent: [ nil ] .\r',			#stamp : 'Anonymous 12/2/2024 17:59',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T18:17:04.649187+01:00' ],		#prior : OmReference [ '224' ],		#self : OmReference [ '225' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r    ^ self objMethodDict at: aSelector ifAbsent: [ nil ] .\r',			#stamp : 'Anonymous 12/2/2024 17:59',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r    ^ self objMethodDict at: aSelector ifAbsent: [ nil ] \r',			#stamp : 'Anonymous 12/2/2024 18:17',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T18:25:46.833187+01:00' ],		#prior : OmReference [ '225' ],		#self : OmReference [ '226' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'lookup:',			#protocol : #'method lookup',			#sourceCode : 'lookup: selector\r\t"look for the method named <selector> starting in the receiver. \r\tThe lookup is done for a message sent to <anObjObject>. self is an objClass"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'lookup:',			#protocol : #'method lookup',			#sourceCode : 'lookup: selector\r\t"look for the method named <selector> starting in the receiver. \r\tThe lookup is done for a message sent to <anObjObject>. self is an objClass"\r| method superclassid |\rmethod := self objMethodDict at: selector ifAbsent: [ nil ].\rmethod ifNil:\r[ superclassid := self objSuperclassId .\rsuperclassid\rifNil: [ ^ nil ]\rifNotNil: [ ^ self objSuperclass lookup: selector ] ]\rifNotNil: [ ^ method . ]\r',			#stamp : 'Anonymous 12/2/2024 18:25',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T18:30:46.161187+01:00' ],		#prior : OmReference [ '226' ],		#self : OmReference [ '227' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r    ^ self objMethodDict at: aSelector ifAbsent: [ nil ] \r',			#stamp : 'Anonymous 12/2/2024 18:17',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'bodyOfMethod:',			#protocol : #'method management',			#sourceCode : 'bodyOfMethod: aSelector\r    "Retourne le corps de la méthode associée au sélecteur donné, ou nil si la méthode n\'existe pas."\r    ^ self objMethodDict at: aSelector ifAbsent: [ \r\tself error: \'Methode non trouvée\', aSelector asString \r\t\r\t ]. \r',			#stamp : 'Anonymous 12/2/2024 18:30',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T18:35:05.065187+01:00' ],		#prior : OmReference [ '227' ],		#self : OmReference [ '228' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'valueOfInstanceVariable:',			#protocol : #'iv management',			#sourceCode : 'valueOfInstanceVariable: aSymbol\r\t^ self valueOfInstanceVariable: aSymbol',			#stamp : 'Anonymous 12/2/2024 16:30',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'valueOfInstanceVariable:',			#protocol : #'iv management',			#sourceCode : 'valueOfInstanceVariable: aSymbol\r|offset|\roffset:= self offsetFromObjectOfInstanceVariable: aSymbol.\r\t^ self  basicAt: offset.',			#stamp : 'Anonymous 12/2/2024 18:35',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T18:37:46.191187+01:00' ],		#prior : OmReference [ '228' ],		#self : OmReference [ '229' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'super:withArguments:from:',			#protocol : #'message passing',			#sourceCode : 'super: selector withArguments: arguments from: aSuperclass\r\t"Invoke an oveeriden method named <selector> with an array of arguments <arguments>.  self is an objClass. aSuperclass should be the superclass of the class containing the method using super"\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'super:withArguments:from:',			#protocol : #'message passing',			#sourceCode : 'super: selector withArguments: arguments from: aSuperclass\r\t"Invoke an oveeriden method named <selector> with an array of arguments <arguments>.  self is an objClass. aSuperclass should be the superclass of the class containing the method using super"\r\r\t^ self basicSend: selector withArguments: arguments from:\raSuperclass .\r',			#stamp : 'Anonymous 12/2/2024 18:37',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T18:40:13.285187+01:00' ],		#prior : OmReference [ '229' ],		#self : OmReference [ '230' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'send:withArguments:',			#protocol : #'message passing',			#sourceCode : 'send: selector withArguments: arguments\r\t"send the message whose selector is <selector> to the receiver. The arguments of the messages are an array <arguments>. The method is lookep up in the class of the receiver. self is an objObject or a objClass."\r\r\t^ self',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Obj,				#isMetaSide : false			},			#name : #'send:withArguments:',			#protocol : #'message passing',			#sourceCode : 'send: selector withArguments: arguments\r^ self basicSend: selector withArguments: arguments from: self\robjClass .\r\r',			#stamp : 'Anonymous 12/2/2024 18:40',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T18:59:53.229187+01:00' ],		#prior : OmReference [ '230' ],		#self : OmReference [ '231' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\HP\\Documents\\Pharo\\images\\project\\project.image'	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T22:10:35.509187+01:00' ],		#prior : OmReference [ '231' ],		#self : OmReference [ '232' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineManualInitializeMethodIn:',			#protocol : #'bootstrap objClass manually',			#sourceCode : 'defineManualInitializeMethodIn: class \r\r\tclass \r\t\taddMethod: #initialize\r\t\targs: \'initArray\'\r\t\twithBody: \t\r\t\t\t\'| objsuperclass |\r\t\t\tobjself initializeUsing: initArray.\t"Initialize a class as an object. In the bootstrapped system will be done via super"\r\t\t\tobjsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].\r\t\t\tobjsuperclass isNil\r\t\t\t\tifFalse: \r\t\t\t\t\t[objself\r\t\t\t\t\t\tobjIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]\r\t\t\t\tifTrue: \r\t\t\t\t\t[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].\r\t\t\tobjself\r\t\t\t\tobjKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).\r\t\t\tobjself objMethodDict: (IdentityDictionary new: 3).\r\t\t\tObj declareClass: objself.\r\t\t\tobjself\'',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineManualInitializeMethodIn:',			#protocol : #'bootstrap objClass manually',			#sourceCode : 'defineManualInitializeMethodIn: objClass \r\r\tobjClass\r\taddMethod: #initialize\r\targs: \'initArray\'\r\twithBody:\r\t\t\'objself super: #initialize withArguments: {initArray} from:\r\t\tsuperClassOfClassDefiningTheMethod.\r\t\tobjself objIVs: (objself\r\t\t\tcomputeNewIVFrom:\r\t\t\t\t(Obj giveClassNamed: objself objSuperclassId) objIVs\r\t\t\twith: objself objIVs).\r\t\tobjself computeAndSetKeywords.\r\t\tobjself objMethodDict: IdentityDictionary new.\r\t\tObj declareClass: objself.\r\t\tobjself\'\r',			#stamp : 'Anonymous 12/2/2024 22:10',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T22:12:43.281187+01:00' ],		#prior : OmReference [ '232' ],		#self : OmReference [ '233' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineInitializeMethodIn:',			#protocol : #'bootstrap objClass',			#sourceCode : 'defineInitializeMethodIn: objClass \r\r\tobjClass \r\t\taddMethod: #initialize\r\t\targs: \'initArray\'\r\t\twithBody: \r\t\t\t\'objself super: #initialize withArguments: {initArray} from: superClassOfClassDefiningTheMethod.\r\t\t\tobjself objIVs: (objself\r\t\t\t\t\t\t\tcomputeNewIVFrom: (Obj giveClassNamed: objself objSuperclassId) objIVs\r\t\t\t\t\t\t\twith: objself objIVs).\r\t\t\tobjself computeAndSetKeywords.\r\t\t\tobjself objMethodDict: IdentityDictionary new.\r\t\t\tObj declareClass: objself.\r\t\t\tobjself\'',			#stamp : 'StephaneDucasse 1/1/2018 20:14',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineInitializeMethodIn:',			#protocol : #'bootstrap objClass',			#sourceCode : 'defineInitializeMethodIn:  class  \r\r\tclass \r\t\taddMethod: #initialize\r\t\targs: \'initArray\'\r\t\twithBody: \t\r\t\t\t\'| objsuperclass |\r\t\t\tobjself initializeUsing: initArray.\t"Initialize a class as an object. In the bootstrapped system will be done via super"\r\t\t\tobjsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].\r\t\t\tobjsuperclass isNil\r\t\t\t\tifFalse: \r\t\t\t\t\t[objself\r\t\t\t\t\t\tobjIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]\r\t\t\t\tifTrue: \r\t\t\t\t\t[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].\r\t\t\tobjself\r\t\t\t\tobjKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).\r\t\t\tobjself objMethodDict: (IdentityDictionary new: 3).\r\t\t\tObj declareClass: objself.\r\t\t\tobjself\'',			#stamp : 'Anonymous 12/2/2024 22:12',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T22:15:33.883187+01:00' ],		#prior : OmReference [ '233' ],		#self : OmReference [ '234' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineManualInitializeMethodIn:',			#protocol : #'bootstrap objClass manually',			#sourceCode : 'defineManualInitializeMethodIn: class \r\r\tclass \r\t\taddMethod: #initialize\r\t\targs: \'initArray\'\r\t\twithBody: \t\r\t\t\t\'| objsuperclass |\r\t\t\tobjself initializeUsing: initArray.\t"Initialize a class as an object. In the bootstrapped system will be done via super"\r\t\t\tobjsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].\r\t\t\tobjsuperclass isNil\r\t\t\t\tifFalse: \r\t\t\t\t\t[objself\r\t\t\t\t\t\tobjIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]\r\t\t\t\tifTrue: \r\t\t\t\t\t[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].\r\t\t\tobjself\r\t\t\t\tobjKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).\r\t\t\tobjself objMethodDict: (IdentityDictionary new: 3).\r\t\t\tObj declareClass: objself.\r\t\t\tobjself\'',			#stamp : 'Anonymous 12/2/2024 22:15',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineManualInitializeMethodIn:',			#protocol : #'bootstrap objClass',			#sourceCode : 'defineManualInitializeMethodIn: class \r\r\tclass \r\t\taddMethod: #initialize\r\t\targs: \'initArray\'\r\t\twithBody: \t\r\t\t\t\'| objsuperclass |\r\t\t\tobjself initializeUsing: initArray.\t"Initialize a class as an object. In the bootstrapped system will be done via super"\r\t\t\tobjsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].\r\t\t\tobjsuperclass isNil\r\t\t\t\tifFalse: \r\t\t\t\t\t[objself\r\t\t\t\t\t\tobjIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]\r\t\t\t\tifTrue: \r\t\t\t\t\t[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].\r\t\t\tobjself\r\t\t\t\tobjKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).\r\t\t\tobjself objMethodDict: (IdentityDictionary new: 3).\r\t\t\tObj declareClass: objself.\r\t\t\tobjself\'',			#stamp : 'Anonymous 12/2/2024 22:15',			#package : #ObjVSkeleton		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-12-02T22:15:33.891187+01:00' ],		#prior : OmReference [ '234' ],		#self : OmReference [ '235' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineManualInitializeMethodIn:',			#protocol : #'bootstrap objClass',			#sourceCode : 'defineManualInitializeMethodIn: objClass \r\r\tobjClass\r\taddMethod: #initialize\r\targs: \'initArray\'\r\twithBody:\r\t\t\'objself super: #initialize withArguments: {initArray} from:\r\t\tsuperClassOfClassDefiningTheMethod.\r\t\tobjself objIVs: (objself\r\t\t\tcomputeNewIVFrom:\r\t\t\t\t(Obj giveClassNamed: objself objSuperclassId) objIVs\r\t\t\twith: objself objIVs).\r\t\tobjself computeAndSetKeywords.\r\t\tobjself objMethodDict: IdentityDictionary new.\r\t\tObj declareClass: objself.\r\t\tobjself\'\r',			#stamp : 'Anonymous 12/2/2024 22:10',			#package : #ObjVSkeleton		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Obj class',				#isMetaSide : true			},			#name : #'defineManualInitializeMethodIn:',			#protocol : #'bootstrap objClass',			#sourceCode : 'defineManualInitializeMethodIn: class \r\r\tclass \r\t\taddMethod: #initialize\r\t\targs: \'initArray\'\r\t\twithBody: \t\r\t\t\t\'| objsuperclass |\r\t\t\tobjself initializeUsing: initArray.\t"Initialize a class as an object. In the bootstrapped system will be done via super"\r\t\t\tobjsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].\r\t\t\tobjsuperclass isNil\r\t\t\t\tifFalse: \r\t\t\t\t\t[objself\r\t\t\t\t\t\tobjIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]\r\t\t\t\tifTrue: \r\t\t\t\t\t[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].\r\t\t\tobjself\r\t\t\t\tobjKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).\r\t\t\tobjself objMethodDict: (IdentityDictionary new: 3).\r\t\t\tObj declareClass: objself.\r\t\t\tobjself\'',			#stamp : 'Anonymous 12/2/2024 22:15',			#package : #ObjVSkeleton		}	}}